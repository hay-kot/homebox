// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/hay-kot/content/backend/ent/authtokens"
	"github.com/hay-kot/content/backend/ent/group"
	"github.com/hay-kot/content/backend/ent/item"
	"github.com/hay-kot/content/backend/ent/itemfield"
	"github.com/hay-kot/content/backend/ent/label"
	"github.com/hay-kot/content/backend/ent/location"
	"github.com/hay-kot/content/backend/ent/predicate"
	"github.com/hay-kot/content/backend/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthTokens = "AuthTokens"
	TypeGroup      = "Group"
	TypeItem       = "Item"
	TypeItemField  = "ItemField"
	TypeLabel      = "Label"
	TypeLocation   = "Location"
	TypeUser       = "User"
)

// AuthTokensMutation represents an operation that mutates the AuthTokens nodes in the graph.
type AuthTokensMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	token         *[]byte
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AuthTokens, error)
	predicates    []predicate.AuthTokens
}

var _ ent.Mutation = (*AuthTokensMutation)(nil)

// authtokensOption allows management of the mutation configuration using functional options.
type authtokensOption func(*AuthTokensMutation)

// newAuthTokensMutation creates new mutation for the AuthTokens entity.
func newAuthTokensMutation(c config, op Op, opts ...authtokensOption) *AuthTokensMutation {
	m := &AuthTokensMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthTokens,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokensID sets the ID field of the mutation.
func withAuthTokensID(id uuid.UUID) authtokensOption {
	return func(m *AuthTokensMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthTokens
		)
		m.oldValue = func(ctx context.Context) (*AuthTokens, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthTokens.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthTokens sets the old AuthTokens of the mutation.
func withAuthTokens(node *AuthTokens) authtokensOption {
	return func(m *AuthTokensMutation) {
		m.oldValue = func(context.Context) (*AuthTokens, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokensMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokensMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthTokens entities.
func (m *AuthTokensMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokensMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokensMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthTokens.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTokensMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTokensMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTokensMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthTokensMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthTokensMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthTokensMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *AuthTokensMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthTokensMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthTokensMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthTokensMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthTokensMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthTokensMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuthTokensMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthTokensMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthTokensMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuthTokensMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthTokensMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthTokensMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuthTokensMutation builder.
func (m *AuthTokensMutation) Where(ps ...predicate.AuthTokens) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthTokensMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthTokens).
func (m *AuthTokensMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokensMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, authtokens.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authtokens.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, authtokens.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, authtokens.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokensMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.CreatedAt()
	case authtokens.FieldUpdatedAt:
		return m.UpdatedAt()
	case authtokens.FieldToken:
		return m.Token()
	case authtokens.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokensMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authtokens.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authtokens.FieldToken:
		return m.OldToken(ctx)
	case authtokens.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthTokens field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtokens.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authtokens.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authtokens.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authtokens.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokensMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokensMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthTokens numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokensMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokensMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokensMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthTokens nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokensMutation) ResetField(name string) error {
	switch name {
	case authtokens.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authtokens.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authtokens.FieldToken:
		m.ResetToken()
		return nil
	case authtokens.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokensMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, authtokens.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokensMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtokens.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokensMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokensMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokensMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, authtokens.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokensMutation) EdgeCleared(name string) bool {
	switch name {
	case authtokens.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokensMutation) ClearEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokensMutation) ResetEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	currency         *group.Currency
	clearedFields    map[string]struct{}
	users            map[uuid.UUID]struct{}
	removedusers     map[uuid.UUID]struct{}
	clearedusers     bool
	locations        map[uuid.UUID]struct{}
	removedlocations map[uuid.UUID]struct{}
	clearedlocations bool
	items            map[uuid.UUID]struct{}
	removeditems     map[uuid.UUID]struct{}
	cleareditems     bool
	labels           map[uuid.UUID]struct{}
	removedlabels    map[uuid.UUID]struct{}
	clearedlabels    bool
	done             bool
	oldValue         func(context.Context) (*Group, error)
	predicates       []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id uuid.UUID) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetCurrency sets the "currency" field.
func (m *GroupMutation) SetCurrency(gr group.Currency) {
	m.currency = &gr
}

// Currency returns the value of the "currency" field in the mutation.
func (m *GroupMutation) Currency() (r group.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCurrency(ctx context.Context) (v group.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *GroupMutation) ResetCurrency() {
	m.currency = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *GroupMutation) AddLocationIDs(ids ...uuid.UUID) {
	if m.locations == nil {
		m.locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *GroupMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *GroupMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *GroupMutation) RemoveLocationIDs(ids ...uuid.UUID) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *GroupMutation) RemovedLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *GroupMutation) LocationsIDs() (ids []uuid.UUID) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *GroupMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *GroupMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *GroupMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *GroupMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *GroupMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *GroupMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *GroupMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *GroupMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddLabelIDs adds the "labels" edge to the Label entity by ids.
func (m *GroupMutation) AddLabelIDs(ids ...uuid.UUID) {
	if m.labels == nil {
		m.labels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.labels[ids[i]] = struct{}{}
	}
}

// ClearLabels clears the "labels" edge to the Label entity.
func (m *GroupMutation) ClearLabels() {
	m.clearedlabels = true
}

// LabelsCleared reports if the "labels" edge to the Label entity was cleared.
func (m *GroupMutation) LabelsCleared() bool {
	return m.clearedlabels
}

// RemoveLabelIDs removes the "labels" edge to the Label entity by IDs.
func (m *GroupMutation) RemoveLabelIDs(ids ...uuid.UUID) {
	if m.removedlabels == nil {
		m.removedlabels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.labels, ids[i])
		m.removedlabels[ids[i]] = struct{}{}
	}
}

// RemovedLabels returns the removed IDs of the "labels" edge to the Label entity.
func (m *GroupMutation) RemovedLabelsIDs() (ids []uuid.UUID) {
	for id := range m.removedlabels {
		ids = append(ids, id)
	}
	return
}

// LabelsIDs returns the "labels" edge IDs in the mutation.
func (m *GroupMutation) LabelsIDs() (ids []uuid.UUID) {
	for id := range m.labels {
		ids = append(ids, id)
	}
	return
}

// ResetLabels resets all changes to the "labels" edge.
func (m *GroupMutation) ResetLabels() {
	m.labels = nil
	m.clearedlabels = false
	m.removedlabels = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.currency != nil {
		fields = append(fields, group.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldCurrency:
		v, ok := value.(group.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.locations != nil {
		edges = append(edges, group.EdgeLocations)
	}
	if m.items != nil {
		edges = append(edges, group.EdgeItems)
	}
	if m.labels != nil {
		edges = append(edges, group.EdgeLabels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.labels))
		for id := range m.labels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.removedlocations != nil {
		edges = append(edges, group.EdgeLocations)
	}
	if m.removeditems != nil {
		edges = append(edges, group.EdgeItems)
	}
	if m.removedlabels != nil {
		edges = append(edges, group.EdgeLabels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.removedlabels))
		for id := range m.removedlabels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedlocations {
		edges = append(edges, group.EdgeLocations)
	}
	if m.cleareditems {
		edges = append(edges, group.EdgeItems)
	}
	if m.clearedlabels {
		edges = append(edges, group.EdgeLabels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeLocations:
		return m.clearedlocations
	case group.EdgeItems:
		return m.cleareditems
	case group.EdgeLabels:
		return m.clearedlabels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeLocations:
		m.ResetLocations()
		return nil
	case group.EdgeItems:
		m.ResetItems()
		return nil
	case group.EdgeLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	description       *string
	notes             *string
	serial_number     *string
	model_number      *string
	manufacturer      *string
	lifetime_warranty *bool
	warranty_expires  *time.Time
	warranty_details  *string
	purchase_time     *time.Time
	purchase_from     *string
	purchase_price    *float64
	addpurchase_price *float64
	sold_time         *time.Time
	sold_to           *string
	sold_price        *float64
	addsold_price     *float64
	sold_notes        *string
	clearedFields     map[string]struct{}
	group             *uuid.UUID
	clearedgroup      bool
	location          *uuid.UUID
	clearedlocation   bool
	fields            map[uuid.UUID]struct{}
	removedfields     map[uuid.UUID]struct{}
	clearedfields     bool
	label             map[uuid.UUID]struct{}
	removedlabel      map[uuid.UUID]struct{}
	clearedlabel      bool
	done              bool
	oldValue          func(context.Context) (*Item, error)
	predicates        []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id uuid.UUID) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[item.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[item.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, item.FieldDescription)
}

// SetNotes sets the "notes" field.
func (m *ItemMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ItemMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ItemMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[item.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ItemMutation) NotesCleared() bool {
	_, ok := m.clearedFields[item.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ItemMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, item.FieldNotes)
}

// SetSerialNumber sets the "serial_number" field.
func (m *ItemMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ItemMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ItemMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[item.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ItemMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[item.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ItemMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, item.FieldSerialNumber)
}

// SetModelNumber sets the "model_number" field.
func (m *ItemMutation) SetModelNumber(s string) {
	m.model_number = &s
}

// ModelNumber returns the value of the "model_number" field in the mutation.
func (m *ItemMutation) ModelNumber() (r string, exists bool) {
	v := m.model_number
	if v == nil {
		return
	}
	return *v, true
}

// OldModelNumber returns the old "model_number" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldModelNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelNumber: %w", err)
	}
	return oldValue.ModelNumber, nil
}

// ClearModelNumber clears the value of the "model_number" field.
func (m *ItemMutation) ClearModelNumber() {
	m.model_number = nil
	m.clearedFields[item.FieldModelNumber] = struct{}{}
}

// ModelNumberCleared returns if the "model_number" field was cleared in this mutation.
func (m *ItemMutation) ModelNumberCleared() bool {
	_, ok := m.clearedFields[item.FieldModelNumber]
	return ok
}

// ResetModelNumber resets all changes to the "model_number" field.
func (m *ItemMutation) ResetModelNumber() {
	m.model_number = nil
	delete(m.clearedFields, item.FieldModelNumber)
}

// SetManufacturer sets the "manufacturer" field.
func (m *ItemMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *ItemMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *ItemMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[item.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *ItemMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[item.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *ItemMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, item.FieldManufacturer)
}

// SetLifetimeWarranty sets the "lifetime_warranty" field.
func (m *ItemMutation) SetLifetimeWarranty(b bool) {
	m.lifetime_warranty = &b
}

// LifetimeWarranty returns the value of the "lifetime_warranty" field in the mutation.
func (m *ItemMutation) LifetimeWarranty() (r bool, exists bool) {
	v := m.lifetime_warranty
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeWarranty returns the old "lifetime_warranty" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldLifetimeWarranty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeWarranty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeWarranty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeWarranty: %w", err)
	}
	return oldValue.LifetimeWarranty, nil
}

// ResetLifetimeWarranty resets all changes to the "lifetime_warranty" field.
func (m *ItemMutation) ResetLifetimeWarranty() {
	m.lifetime_warranty = nil
}

// SetWarrantyExpires sets the "warranty_expires" field.
func (m *ItemMutation) SetWarrantyExpires(t time.Time) {
	m.warranty_expires = &t
}

// WarrantyExpires returns the value of the "warranty_expires" field in the mutation.
func (m *ItemMutation) WarrantyExpires() (r time.Time, exists bool) {
	v := m.warranty_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyExpires returns the old "warranty_expires" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldWarrantyExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyExpires: %w", err)
	}
	return oldValue.WarrantyExpires, nil
}

// ClearWarrantyExpires clears the value of the "warranty_expires" field.
func (m *ItemMutation) ClearWarrantyExpires() {
	m.warranty_expires = nil
	m.clearedFields[item.FieldWarrantyExpires] = struct{}{}
}

// WarrantyExpiresCleared returns if the "warranty_expires" field was cleared in this mutation.
func (m *ItemMutation) WarrantyExpiresCleared() bool {
	_, ok := m.clearedFields[item.FieldWarrantyExpires]
	return ok
}

// ResetWarrantyExpires resets all changes to the "warranty_expires" field.
func (m *ItemMutation) ResetWarrantyExpires() {
	m.warranty_expires = nil
	delete(m.clearedFields, item.FieldWarrantyExpires)
}

// SetWarrantyDetails sets the "warranty_details" field.
func (m *ItemMutation) SetWarrantyDetails(s string) {
	m.warranty_details = &s
}

// WarrantyDetails returns the value of the "warranty_details" field in the mutation.
func (m *ItemMutation) WarrantyDetails() (r string, exists bool) {
	v := m.warranty_details
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyDetails returns the old "warranty_details" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldWarrantyDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyDetails: %w", err)
	}
	return oldValue.WarrantyDetails, nil
}

// ClearWarrantyDetails clears the value of the "warranty_details" field.
func (m *ItemMutation) ClearWarrantyDetails() {
	m.warranty_details = nil
	m.clearedFields[item.FieldWarrantyDetails] = struct{}{}
}

// WarrantyDetailsCleared returns if the "warranty_details" field was cleared in this mutation.
func (m *ItemMutation) WarrantyDetailsCleared() bool {
	_, ok := m.clearedFields[item.FieldWarrantyDetails]
	return ok
}

// ResetWarrantyDetails resets all changes to the "warranty_details" field.
func (m *ItemMutation) ResetWarrantyDetails() {
	m.warranty_details = nil
	delete(m.clearedFields, item.FieldWarrantyDetails)
}

// SetPurchaseTime sets the "purchase_time" field.
func (m *ItemMutation) SetPurchaseTime(t time.Time) {
	m.purchase_time = &t
}

// PurchaseTime returns the value of the "purchase_time" field in the mutation.
func (m *ItemMutation) PurchaseTime() (r time.Time, exists bool) {
	v := m.purchase_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseTime returns the old "purchase_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchaseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseTime: %w", err)
	}
	return oldValue.PurchaseTime, nil
}

// ClearPurchaseTime clears the value of the "purchase_time" field.
func (m *ItemMutation) ClearPurchaseTime() {
	m.purchase_time = nil
	m.clearedFields[item.FieldPurchaseTime] = struct{}{}
}

// PurchaseTimeCleared returns if the "purchase_time" field was cleared in this mutation.
func (m *ItemMutation) PurchaseTimeCleared() bool {
	_, ok := m.clearedFields[item.FieldPurchaseTime]
	return ok
}

// ResetPurchaseTime resets all changes to the "purchase_time" field.
func (m *ItemMutation) ResetPurchaseTime() {
	m.purchase_time = nil
	delete(m.clearedFields, item.FieldPurchaseTime)
}

// SetPurchaseFrom sets the "purchase_from" field.
func (m *ItemMutation) SetPurchaseFrom(s string) {
	m.purchase_from = &s
}

// PurchaseFrom returns the value of the "purchase_from" field in the mutation.
func (m *ItemMutation) PurchaseFrom() (r string, exists bool) {
	v := m.purchase_from
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseFrom returns the old "purchase_from" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchaseFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseFrom: %w", err)
	}
	return oldValue.PurchaseFrom, nil
}

// ClearPurchaseFrom clears the value of the "purchase_from" field.
func (m *ItemMutation) ClearPurchaseFrom() {
	m.purchase_from = nil
	m.clearedFields[item.FieldPurchaseFrom] = struct{}{}
}

// PurchaseFromCleared returns if the "purchase_from" field was cleared in this mutation.
func (m *ItemMutation) PurchaseFromCleared() bool {
	_, ok := m.clearedFields[item.FieldPurchaseFrom]
	return ok
}

// ResetPurchaseFrom resets all changes to the "purchase_from" field.
func (m *ItemMutation) ResetPurchaseFrom() {
	m.purchase_from = nil
	delete(m.clearedFields, item.FieldPurchaseFrom)
}

// SetPurchasePrice sets the "purchase_price" field.
func (m *ItemMutation) SetPurchasePrice(f float64) {
	m.purchase_price = &f
	m.addpurchase_price = nil
}

// PurchasePrice returns the value of the "purchase_price" field in the mutation.
func (m *ItemMutation) PurchasePrice() (r float64, exists bool) {
	v := m.purchase_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasePrice returns the old "purchase_price" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchasePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasePrice: %w", err)
	}
	return oldValue.PurchasePrice, nil
}

// AddPurchasePrice adds f to the "purchase_price" field.
func (m *ItemMutation) AddPurchasePrice(f float64) {
	if m.addpurchase_price != nil {
		*m.addpurchase_price += f
	} else {
		m.addpurchase_price = &f
	}
}

// AddedPurchasePrice returns the value that was added to the "purchase_price" field in this mutation.
func (m *ItemMutation) AddedPurchasePrice() (r float64, exists bool) {
	v := m.addpurchase_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchasePrice resets all changes to the "purchase_price" field.
func (m *ItemMutation) ResetPurchasePrice() {
	m.purchase_price = nil
	m.addpurchase_price = nil
}

// SetSoldTime sets the "sold_time" field.
func (m *ItemMutation) SetSoldTime(t time.Time) {
	m.sold_time = &t
}

// SoldTime returns the value of the "sold_time" field in the mutation.
func (m *ItemMutation) SoldTime() (r time.Time, exists bool) {
	v := m.sold_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTime returns the old "sold_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTime: %w", err)
	}
	return oldValue.SoldTime, nil
}

// ClearSoldTime clears the value of the "sold_time" field.
func (m *ItemMutation) ClearSoldTime() {
	m.sold_time = nil
	m.clearedFields[item.FieldSoldTime] = struct{}{}
}

// SoldTimeCleared returns if the "sold_time" field was cleared in this mutation.
func (m *ItemMutation) SoldTimeCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldTime]
	return ok
}

// ResetSoldTime resets all changes to the "sold_time" field.
func (m *ItemMutation) ResetSoldTime() {
	m.sold_time = nil
	delete(m.clearedFields, item.FieldSoldTime)
}

// SetSoldTo sets the "sold_to" field.
func (m *ItemMutation) SetSoldTo(s string) {
	m.sold_to = &s
}

// SoldTo returns the value of the "sold_to" field in the mutation.
func (m *ItemMutation) SoldTo() (r string, exists bool) {
	v := m.sold_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTo returns the old "sold_to" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTo: %w", err)
	}
	return oldValue.SoldTo, nil
}

// ClearSoldTo clears the value of the "sold_to" field.
func (m *ItemMutation) ClearSoldTo() {
	m.sold_to = nil
	m.clearedFields[item.FieldSoldTo] = struct{}{}
}

// SoldToCleared returns if the "sold_to" field was cleared in this mutation.
func (m *ItemMutation) SoldToCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldTo]
	return ok
}

// ResetSoldTo resets all changes to the "sold_to" field.
func (m *ItemMutation) ResetSoldTo() {
	m.sold_to = nil
	delete(m.clearedFields, item.FieldSoldTo)
}

// SetSoldPrice sets the "sold_price" field.
func (m *ItemMutation) SetSoldPrice(f float64) {
	m.sold_price = &f
	m.addsold_price = nil
}

// SoldPrice returns the value of the "sold_price" field in the mutation.
func (m *ItemMutation) SoldPrice() (r float64, exists bool) {
	v := m.sold_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldPrice returns the old "sold_price" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldPrice: %w", err)
	}
	return oldValue.SoldPrice, nil
}

// AddSoldPrice adds f to the "sold_price" field.
func (m *ItemMutation) AddSoldPrice(f float64) {
	if m.addsold_price != nil {
		*m.addsold_price += f
	} else {
		m.addsold_price = &f
	}
}

// AddedSoldPrice returns the value that was added to the "sold_price" field in this mutation.
func (m *ItemMutation) AddedSoldPrice() (r float64, exists bool) {
	v := m.addsold_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoldPrice resets all changes to the "sold_price" field.
func (m *ItemMutation) ResetSoldPrice() {
	m.sold_price = nil
	m.addsold_price = nil
}

// SetSoldNotes sets the "sold_notes" field.
func (m *ItemMutation) SetSoldNotes(s string) {
	m.sold_notes = &s
}

// SoldNotes returns the value of the "sold_notes" field in the mutation.
func (m *ItemMutation) SoldNotes() (r string, exists bool) {
	v := m.sold_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldNotes returns the old "sold_notes" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldNotes: %w", err)
	}
	return oldValue.SoldNotes, nil
}

// ClearSoldNotes clears the value of the "sold_notes" field.
func (m *ItemMutation) ClearSoldNotes() {
	m.sold_notes = nil
	m.clearedFields[item.FieldSoldNotes] = struct{}{}
}

// SoldNotesCleared returns if the "sold_notes" field was cleared in this mutation.
func (m *ItemMutation) SoldNotesCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldNotes]
	return ok
}

// ResetSoldNotes resets all changes to the "sold_notes" field.
func (m *ItemMutation) ResetSoldNotes() {
	m.sold_notes = nil
	delete(m.clearedFields, item.FieldSoldNotes)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *ItemMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *ItemMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *ItemMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *ItemMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *ItemMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ItemMutation) SetLocationID(id uuid.UUID) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ItemMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ItemMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ItemMutation) LocationID() (id uuid.UUID, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ItemMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddFieldIDs adds the "fields" edge to the ItemField entity by ids.
func (m *ItemMutation) AddFieldIDs(ids ...uuid.UUID) {
	if m.fields == nil {
		m.fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the ItemField entity.
func (m *ItemMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the ItemField entity was cleared.
func (m *ItemMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the ItemField entity by IDs.
func (m *ItemMutation) RemoveFieldIDs(ids ...uuid.UUID) {
	if m.removedfields == nil {
		m.removedfields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the ItemField entity.
func (m *ItemMutation) RemovedFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *ItemMutation) FieldsIDs() (ids []uuid.UUID) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *ItemMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// AddLabelIDs adds the "label" edge to the Label entity by ids.
func (m *ItemMutation) AddLabelIDs(ids ...uuid.UUID) {
	if m.label == nil {
		m.label = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.label[ids[i]] = struct{}{}
	}
}

// ClearLabel clears the "label" edge to the Label entity.
func (m *ItemMutation) ClearLabel() {
	m.clearedlabel = true
}

// LabelCleared reports if the "label" edge to the Label entity was cleared.
func (m *ItemMutation) LabelCleared() bool {
	return m.clearedlabel
}

// RemoveLabelIDs removes the "label" edge to the Label entity by IDs.
func (m *ItemMutation) RemoveLabelIDs(ids ...uuid.UUID) {
	if m.removedlabel == nil {
		m.removedlabel = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.label, ids[i])
		m.removedlabel[ids[i]] = struct{}{}
	}
}

// RemovedLabel returns the removed IDs of the "label" edge to the Label entity.
func (m *ItemMutation) RemovedLabelIDs() (ids []uuid.UUID) {
	for id := range m.removedlabel {
		ids = append(ids, id)
	}
	return
}

// LabelIDs returns the "label" edge IDs in the mutation.
func (m *ItemMutation) LabelIDs() (ids []uuid.UUID) {
	for id := range m.label {
		ids = append(ids, id)
	}
	return
}

// ResetLabel resets all changes to the "label" edge.
func (m *ItemMutation) ResetLabel() {
	m.label = nil
	m.clearedlabel = false
	m.removedlabel = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, item.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, item.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.description != nil {
		fields = append(fields, item.FieldDescription)
	}
	if m.notes != nil {
		fields = append(fields, item.FieldNotes)
	}
	if m.serial_number != nil {
		fields = append(fields, item.FieldSerialNumber)
	}
	if m.model_number != nil {
		fields = append(fields, item.FieldModelNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, item.FieldManufacturer)
	}
	if m.lifetime_warranty != nil {
		fields = append(fields, item.FieldLifetimeWarranty)
	}
	if m.warranty_expires != nil {
		fields = append(fields, item.FieldWarrantyExpires)
	}
	if m.warranty_details != nil {
		fields = append(fields, item.FieldWarrantyDetails)
	}
	if m.purchase_time != nil {
		fields = append(fields, item.FieldPurchaseTime)
	}
	if m.purchase_from != nil {
		fields = append(fields, item.FieldPurchaseFrom)
	}
	if m.purchase_price != nil {
		fields = append(fields, item.FieldPurchasePrice)
	}
	if m.sold_time != nil {
		fields = append(fields, item.FieldSoldTime)
	}
	if m.sold_to != nil {
		fields = append(fields, item.FieldSoldTo)
	}
	if m.sold_price != nil {
		fields = append(fields, item.FieldSoldPrice)
	}
	if m.sold_notes != nil {
		fields = append(fields, item.FieldSoldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCreatedAt:
		return m.CreatedAt()
	case item.FieldUpdatedAt:
		return m.UpdatedAt()
	case item.FieldName:
		return m.Name()
	case item.FieldDescription:
		return m.Description()
	case item.FieldNotes:
		return m.Notes()
	case item.FieldSerialNumber:
		return m.SerialNumber()
	case item.FieldModelNumber:
		return m.ModelNumber()
	case item.FieldManufacturer:
		return m.Manufacturer()
	case item.FieldLifetimeWarranty:
		return m.LifetimeWarranty()
	case item.FieldWarrantyExpires:
		return m.WarrantyExpires()
	case item.FieldWarrantyDetails:
		return m.WarrantyDetails()
	case item.FieldPurchaseTime:
		return m.PurchaseTime()
	case item.FieldPurchaseFrom:
		return m.PurchaseFrom()
	case item.FieldPurchasePrice:
		return m.PurchasePrice()
	case item.FieldSoldTime:
		return m.SoldTime()
	case item.FieldSoldTo:
		return m.SoldTo()
	case item.FieldSoldPrice:
		return m.SoldPrice()
	case item.FieldSoldNotes:
		return m.SoldNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case item.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldDescription:
		return m.OldDescription(ctx)
	case item.FieldNotes:
		return m.OldNotes(ctx)
	case item.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case item.FieldModelNumber:
		return m.OldModelNumber(ctx)
	case item.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case item.FieldLifetimeWarranty:
		return m.OldLifetimeWarranty(ctx)
	case item.FieldWarrantyExpires:
		return m.OldWarrantyExpires(ctx)
	case item.FieldWarrantyDetails:
		return m.OldWarrantyDetails(ctx)
	case item.FieldPurchaseTime:
		return m.OldPurchaseTime(ctx)
	case item.FieldPurchaseFrom:
		return m.OldPurchaseFrom(ctx)
	case item.FieldPurchasePrice:
		return m.OldPurchasePrice(ctx)
	case item.FieldSoldTime:
		return m.OldSoldTime(ctx)
	case item.FieldSoldTo:
		return m.OldSoldTo(ctx)
	case item.FieldSoldPrice:
		return m.OldSoldPrice(ctx)
	case item.FieldSoldNotes:
		return m.OldSoldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case item.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case item.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case item.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case item.FieldModelNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelNumber(v)
		return nil
	case item.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case item.FieldLifetimeWarranty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeWarranty(v)
		return nil
	case item.FieldWarrantyExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyExpires(v)
		return nil
	case item.FieldWarrantyDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyDetails(v)
		return nil
	case item.FieldPurchaseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseTime(v)
		return nil
	case item.FieldPurchaseFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseFrom(v)
		return nil
	case item.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasePrice(v)
		return nil
	case item.FieldSoldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTime(v)
		return nil
	case item.FieldSoldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTo(v)
		return nil
	case item.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldPrice(v)
		return nil
	case item.FieldSoldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addpurchase_price != nil {
		fields = append(fields, item.FieldPurchasePrice)
	}
	if m.addsold_price != nil {
		fields = append(fields, item.FieldSoldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldPurchasePrice:
		return m.AddedPurchasePrice()
	case item.FieldSoldPrice:
		return m.AddedSoldPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchasePrice(v)
		return nil
	case item.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoldPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldDescription) {
		fields = append(fields, item.FieldDescription)
	}
	if m.FieldCleared(item.FieldNotes) {
		fields = append(fields, item.FieldNotes)
	}
	if m.FieldCleared(item.FieldSerialNumber) {
		fields = append(fields, item.FieldSerialNumber)
	}
	if m.FieldCleared(item.FieldModelNumber) {
		fields = append(fields, item.FieldModelNumber)
	}
	if m.FieldCleared(item.FieldManufacturer) {
		fields = append(fields, item.FieldManufacturer)
	}
	if m.FieldCleared(item.FieldWarrantyExpires) {
		fields = append(fields, item.FieldWarrantyExpires)
	}
	if m.FieldCleared(item.FieldWarrantyDetails) {
		fields = append(fields, item.FieldWarrantyDetails)
	}
	if m.FieldCleared(item.FieldPurchaseTime) {
		fields = append(fields, item.FieldPurchaseTime)
	}
	if m.FieldCleared(item.FieldPurchaseFrom) {
		fields = append(fields, item.FieldPurchaseFrom)
	}
	if m.FieldCleared(item.FieldSoldTime) {
		fields = append(fields, item.FieldSoldTime)
	}
	if m.FieldCleared(item.FieldSoldTo) {
		fields = append(fields, item.FieldSoldTo)
	}
	if m.FieldCleared(item.FieldSoldNotes) {
		fields = append(fields, item.FieldSoldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldDescription:
		m.ClearDescription()
		return nil
	case item.FieldNotes:
		m.ClearNotes()
		return nil
	case item.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case item.FieldModelNumber:
		m.ClearModelNumber()
		return nil
	case item.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case item.FieldWarrantyExpires:
		m.ClearWarrantyExpires()
		return nil
	case item.FieldWarrantyDetails:
		m.ClearWarrantyDetails()
		return nil
	case item.FieldPurchaseTime:
		m.ClearPurchaseTime()
		return nil
	case item.FieldPurchaseFrom:
		m.ClearPurchaseFrom()
		return nil
	case item.FieldSoldTime:
		m.ClearSoldTime()
		return nil
	case item.FieldSoldTo:
		m.ClearSoldTo()
		return nil
	case item.FieldSoldNotes:
		m.ClearSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case item.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldDescription:
		m.ResetDescription()
		return nil
	case item.FieldNotes:
		m.ResetNotes()
		return nil
	case item.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case item.FieldModelNumber:
		m.ResetModelNumber()
		return nil
	case item.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case item.FieldLifetimeWarranty:
		m.ResetLifetimeWarranty()
		return nil
	case item.FieldWarrantyExpires:
		m.ResetWarrantyExpires()
		return nil
	case item.FieldWarrantyDetails:
		m.ResetWarrantyDetails()
		return nil
	case item.FieldPurchaseTime:
		m.ResetPurchaseTime()
		return nil
	case item.FieldPurchaseFrom:
		m.ResetPurchaseFrom()
		return nil
	case item.FieldPurchasePrice:
		m.ResetPurchasePrice()
		return nil
	case item.FieldSoldTime:
		m.ResetSoldTime()
		return nil
	case item.FieldSoldTo:
		m.ResetSoldTo()
		return nil
	case item.FieldSoldPrice:
		m.ResetSoldPrice()
		return nil
	case item.FieldSoldNotes:
		m.ResetSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.group != nil {
		edges = append(edges, item.EdgeGroup)
	}
	if m.location != nil {
		edges = append(edges, item.EdgeLocation)
	}
	if m.fields != nil {
		edges = append(edges, item.EdgeFields)
	}
	if m.label != nil {
		edges = append(edges, item.EdgeLabel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.label))
		for id := range m.label {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfields != nil {
		edges = append(edges, item.EdgeFields)
	}
	if m.removedlabel != nil {
		edges = append(edges, item.EdgeLabel)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.removedlabel))
		for id := range m.removedlabel {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgroup {
		edges = append(edges, item.EdgeGroup)
	}
	if m.clearedlocation {
		edges = append(edges, item.EdgeLocation)
	}
	if m.clearedfields {
		edges = append(edges, item.EdgeFields)
	}
	if m.clearedlabel {
		edges = append(edges, item.EdgeLabel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeGroup:
		return m.clearedgroup
	case item.EdgeLocation:
		return m.clearedlocation
	case item.EdgeFields:
		return m.clearedfields
	case item.EdgeLabel:
		return m.clearedlabel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	case item.EdgeGroup:
		m.ClearGroup()
		return nil
	case item.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeGroup:
		m.ResetGroup()
		return nil
	case item.EdgeLocation:
		m.ResetLocation()
		return nil
	case item.EdgeFields:
		m.ResetFields()
		return nil
	case item.EdgeLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// ItemFieldMutation represents an operation that mutates the ItemField nodes in the graph.
type ItemFieldMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	_type           *itemfield.Type
	text_value      *string
	number_value    *int
	addnumber_value *int
	boolean_value   *bool
	time_value      *time.Time
	clearedFields   map[string]struct{}
	item            *uuid.UUID
	cleareditem     bool
	done            bool
	oldValue        func(context.Context) (*ItemField, error)
	predicates      []predicate.ItemField
}

var _ ent.Mutation = (*ItemFieldMutation)(nil)

// itemfieldOption allows management of the mutation configuration using functional options.
type itemfieldOption func(*ItemFieldMutation)

// newItemFieldMutation creates new mutation for the ItemField entity.
func newItemFieldMutation(c config, op Op, opts ...itemfieldOption) *ItemFieldMutation {
	m := &ItemFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeItemField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemFieldID sets the ID field of the mutation.
func withItemFieldID(id uuid.UUID) itemfieldOption {
	return func(m *ItemFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *ItemField
		)
		m.oldValue = func(ctx context.Context) (*ItemField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ItemField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItemField sets the old ItemField of the mutation.
func withItemField(node *ItemField) itemfieldOption {
	return func(m *ItemFieldMutation) {
		m.oldValue = func(context.Context) (*ItemField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ItemField entities.
func (m *ItemFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ItemField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemFieldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemFieldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemFieldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemFieldMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemFieldMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemFieldMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemFieldMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemFieldMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemFieldMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemFieldMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[itemfield.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemFieldMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemFieldMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, itemfield.FieldDescription)
}

// SetType sets the "type" field.
func (m *ItemFieldMutation) SetType(i itemfield.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemFieldMutation) GetType() (r itemfield.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldType(ctx context.Context) (v itemfield.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemFieldMutation) ResetType() {
	m._type = nil
}

// SetTextValue sets the "text_value" field.
func (m *ItemFieldMutation) SetTextValue(s string) {
	m.text_value = &s
}

// TextValue returns the value of the "text_value" field in the mutation.
func (m *ItemFieldMutation) TextValue() (r string, exists bool) {
	v := m.text_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTextValue returns the old "text_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldTextValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextValue: %w", err)
	}
	return oldValue.TextValue, nil
}

// ClearTextValue clears the value of the "text_value" field.
func (m *ItemFieldMutation) ClearTextValue() {
	m.text_value = nil
	m.clearedFields[itemfield.FieldTextValue] = struct{}{}
}

// TextValueCleared returns if the "text_value" field was cleared in this mutation.
func (m *ItemFieldMutation) TextValueCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldTextValue]
	return ok
}

// ResetTextValue resets all changes to the "text_value" field.
func (m *ItemFieldMutation) ResetTextValue() {
	m.text_value = nil
	delete(m.clearedFields, itemfield.FieldTextValue)
}

// SetNumberValue sets the "number_value" field.
func (m *ItemFieldMutation) SetNumberValue(i int) {
	m.number_value = &i
	m.addnumber_value = nil
}

// NumberValue returns the value of the "number_value" field in the mutation.
func (m *ItemFieldMutation) NumberValue() (r int, exists bool) {
	v := m.number_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberValue returns the old "number_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldNumberValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberValue: %w", err)
	}
	return oldValue.NumberValue, nil
}

// AddNumberValue adds i to the "number_value" field.
func (m *ItemFieldMutation) AddNumberValue(i int) {
	if m.addnumber_value != nil {
		*m.addnumber_value += i
	} else {
		m.addnumber_value = &i
	}
}

// AddedNumberValue returns the value that was added to the "number_value" field in this mutation.
func (m *ItemFieldMutation) AddedNumberValue() (r int, exists bool) {
	v := m.addnumber_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberValue clears the value of the "number_value" field.
func (m *ItemFieldMutation) ClearNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	m.clearedFields[itemfield.FieldNumberValue] = struct{}{}
}

// NumberValueCleared returns if the "number_value" field was cleared in this mutation.
func (m *ItemFieldMutation) NumberValueCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldNumberValue]
	return ok
}

// ResetNumberValue resets all changes to the "number_value" field.
func (m *ItemFieldMutation) ResetNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	delete(m.clearedFields, itemfield.FieldNumberValue)
}

// SetBooleanValue sets the "boolean_value" field.
func (m *ItemFieldMutation) SetBooleanValue(b bool) {
	m.boolean_value = &b
}

// BooleanValue returns the value of the "boolean_value" field in the mutation.
func (m *ItemFieldMutation) BooleanValue() (r bool, exists bool) {
	v := m.boolean_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBooleanValue returns the old "boolean_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldBooleanValue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBooleanValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBooleanValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBooleanValue: %w", err)
	}
	return oldValue.BooleanValue, nil
}

// ResetBooleanValue resets all changes to the "boolean_value" field.
func (m *ItemFieldMutation) ResetBooleanValue() {
	m.boolean_value = nil
}

// SetTimeValue sets the "time_value" field.
func (m *ItemFieldMutation) SetTimeValue(t time.Time) {
	m.time_value = &t
}

// TimeValue returns the value of the "time_value" field in the mutation.
func (m *ItemFieldMutation) TimeValue() (r time.Time, exists bool) {
	v := m.time_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeValue returns the old "time_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldTimeValue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeValue: %w", err)
	}
	return oldValue.TimeValue, nil
}

// ResetTimeValue resets all changes to the "time_value" field.
func (m *ItemFieldMutation) ResetTimeValue() {
	m.time_value = nil
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *ItemFieldMutation) SetItemID(id uuid.UUID) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *ItemFieldMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *ItemFieldMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *ItemFieldMutation) ItemID() (id uuid.UUID, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *ItemFieldMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *ItemFieldMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the ItemFieldMutation builder.
func (m *ItemFieldMutation) Where(ps ...predicate.ItemField) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemFieldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ItemField).
func (m *ItemFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemFieldMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, itemfield.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, itemfield.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, itemfield.FieldName)
	}
	if m.description != nil {
		fields = append(fields, itemfield.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, itemfield.FieldType)
	}
	if m.text_value != nil {
		fields = append(fields, itemfield.FieldTextValue)
	}
	if m.number_value != nil {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	if m.boolean_value != nil {
		fields = append(fields, itemfield.FieldBooleanValue)
	}
	if m.time_value != nil {
		fields = append(fields, itemfield.FieldTimeValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itemfield.FieldCreatedAt:
		return m.CreatedAt()
	case itemfield.FieldUpdatedAt:
		return m.UpdatedAt()
	case itemfield.FieldName:
		return m.Name()
	case itemfield.FieldDescription:
		return m.Description()
	case itemfield.FieldType:
		return m.GetType()
	case itemfield.FieldTextValue:
		return m.TextValue()
	case itemfield.FieldNumberValue:
		return m.NumberValue()
	case itemfield.FieldBooleanValue:
		return m.BooleanValue()
	case itemfield.FieldTimeValue:
		return m.TimeValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itemfield.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case itemfield.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case itemfield.FieldName:
		return m.OldName(ctx)
	case itemfield.FieldDescription:
		return m.OldDescription(ctx)
	case itemfield.FieldType:
		return m.OldType(ctx)
	case itemfield.FieldTextValue:
		return m.OldTextValue(ctx)
	case itemfield.FieldNumberValue:
		return m.OldNumberValue(ctx)
	case itemfield.FieldBooleanValue:
		return m.OldBooleanValue(ctx)
	case itemfield.FieldTimeValue:
		return m.OldTimeValue(ctx)
	}
	return nil, fmt.Errorf("unknown ItemField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itemfield.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case itemfield.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case itemfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case itemfield.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case itemfield.FieldType:
		v, ok := value.(itemfield.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case itemfield.FieldTextValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextValue(v)
		return nil
	case itemfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberValue(v)
		return nil
	case itemfield.FieldBooleanValue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBooleanValue(v)
		return nil
	case itemfield.FieldTimeValue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeValue(v)
		return nil
	}
	return fmt.Errorf("unknown ItemField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemFieldMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_value != nil {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case itemfield.FieldNumberValue:
		return m.AddedNumberValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case itemfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberValue(v)
		return nil
	}
	return fmt.Errorf("unknown ItemField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(itemfield.FieldDescription) {
		fields = append(fields, itemfield.FieldDescription)
	}
	if m.FieldCleared(itemfield.FieldTextValue) {
		fields = append(fields, itemfield.FieldTextValue)
	}
	if m.FieldCleared(itemfield.FieldNumberValue) {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemFieldMutation) ClearField(name string) error {
	switch name {
	case itemfield.FieldDescription:
		m.ClearDescription()
		return nil
	case itemfield.FieldTextValue:
		m.ClearTextValue()
		return nil
	case itemfield.FieldNumberValue:
		m.ClearNumberValue()
		return nil
	}
	return fmt.Errorf("unknown ItemField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemFieldMutation) ResetField(name string) error {
	switch name {
	case itemfield.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case itemfield.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case itemfield.FieldName:
		m.ResetName()
		return nil
	case itemfield.FieldDescription:
		m.ResetDescription()
		return nil
	case itemfield.FieldType:
		m.ResetType()
		return nil
	case itemfield.FieldTextValue:
		m.ResetTextValue()
		return nil
	case itemfield.FieldNumberValue:
		m.ResetNumberValue()
		return nil
	case itemfield.FieldBooleanValue:
		m.ResetBooleanValue()
		return nil
	case itemfield.FieldTimeValue:
		m.ResetTimeValue()
		return nil
	}
	return fmt.Errorf("unknown ItemField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item != nil {
		edges = append(edges, itemfield.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itemfield.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem {
		edges = append(edges, itemfield.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case itemfield.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemFieldMutation) ClearEdge(name string) error {
	switch name {
	case itemfield.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown ItemField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemFieldMutation) ResetEdge(name string) error {
	switch name {
	case itemfield.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown ItemField edge %s", name)
}

// LabelMutation represents an operation that mutates the Label nodes in the graph.
type LabelMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	color         *string
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	items         map[uuid.UUID]struct{}
	removeditems  map[uuid.UUID]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Label, error)
	predicates    []predicate.Label
}

var _ ent.Mutation = (*LabelMutation)(nil)

// labelOption allows management of the mutation configuration using functional options.
type labelOption func(*LabelMutation)

// newLabelMutation creates new mutation for the Label entity.
func newLabelMutation(c config, op Op, opts ...labelOption) *LabelMutation {
	m := &LabelMutation{
		config:        c,
		op:            op,
		typ:           TypeLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLabelID sets the ID field of the mutation.
func withLabelID(id uuid.UUID) labelOption {
	return func(m *LabelMutation) {
		var (
			err   error
			once  sync.Once
			value *Label
		)
		m.oldValue = func(ctx context.Context) (*Label, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Label.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLabel sets the old Label of the mutation.
func withLabel(node *Label) labelOption {
	return func(m *LabelMutation) {
		m.oldValue = func(context.Context) (*Label, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Label entities.
func (m *LabelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Label.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LabelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LabelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LabelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LabelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LabelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *LabelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LabelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LabelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LabelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LabelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LabelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[label.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LabelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[label.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LabelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, label.FieldDescription)
}

// SetColor sets the "color" field.
func (m *LabelMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LabelMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *LabelMutation) ClearColor() {
	m.color = nil
	m.clearedFields[label.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *LabelMutation) ColorCleared() bool {
	_, ok := m.clearedFields[label.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *LabelMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, label.FieldColor)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *LabelMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *LabelMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *LabelMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *LabelMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *LabelMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *LabelMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *LabelMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *LabelMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *LabelMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *LabelMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *LabelMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *LabelMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *LabelMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the LabelMutation builder.
func (m *LabelMutation) Where(ps ...predicate.Label) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LabelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Label).
func (m *LabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, label.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, label.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, label.FieldName)
	}
	if m.description != nil {
		fields = append(fields, label.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, label.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case label.FieldCreatedAt:
		return m.CreatedAt()
	case label.FieldUpdatedAt:
		return m.UpdatedAt()
	case label.FieldName:
		return m.Name()
	case label.FieldDescription:
		return m.Description()
	case label.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case label.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case label.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case label.FieldName:
		return m.OldName(ctx)
	case label.FieldDescription:
		return m.OldDescription(ctx)
	case label.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Label field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case label.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case label.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case label.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case label.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case label.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Label numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(label.FieldDescription) {
		fields = append(fields, label.FieldDescription)
	}
	if m.FieldCleared(label.FieldColor) {
		fields = append(fields, label.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabelMutation) ClearField(name string) error {
	switch name {
	case label.FieldDescription:
		m.ClearDescription()
		return nil
	case label.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Label nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabelMutation) ResetField(name string) error {
	switch name {
	case label.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case label.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case label.FieldName:
		m.ResetName()
		return nil
	case label.FieldDescription:
		m.ResetDescription()
		return nil
	case label.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, label.EdgeGroup)
	}
	if m.items != nil {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case label.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, label.EdgeGroup)
	}
	if m.cleareditems {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabelMutation) EdgeCleared(name string) bool {
	switch name {
	case label.EdgeGroup:
		return m.clearedgroup
	case label.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabelMutation) ClearEdge(name string) error {
	switch name {
	case label.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Label unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabelMutation) ResetEdge(name string) error {
	switch name {
	case label.EdgeGroup:
		m.ResetGroup()
		return nil
	case label.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Label edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	items         map[uuid.UUID]struct{}
	removeditems  map[uuid.UUID]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Location, error)
	predicates    []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uuid.UUID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *LocationMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *LocationMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *LocationMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *LocationMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *LocationMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *LocationMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *LocationMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *LocationMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *LocationMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *LocationMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *LocationMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *LocationMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldName:
		return m.Name()
	case location.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, location.EdgeGroup)
	}
	if m.items != nil {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, location.EdgeGroup)
	}
	if m.cleareditems {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeGroup:
		return m.clearedgroup
	case location.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeGroup:
		m.ResetGroup()
		return nil
	case location.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	email              *string
	password           *string
	is_superuser       *bool
	clearedFields      map[string]struct{}
	group              *uuid.UUID
	clearedgroup       bool
	auth_tokens        map[uuid.UUID]struct{}
	removedauth_tokens map[uuid.UUID]struct{}
	clearedauth_tokens bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsSuperuser sets the "is_superuser" field.
func (m *UserMutation) SetIsSuperuser(b bool) {
	m.is_superuser = &b
}

// IsSuperuser returns the value of the "is_superuser" field in the mutation.
func (m *UserMutation) IsSuperuser() (r bool, exists bool) {
	v := m.is_superuser
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperuser returns the old "is_superuser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperuser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperuser: %w", err)
	}
	return oldValue.IsSuperuser, nil
}

// ResetIsSuperuser resets all changes to the "is_superuser" field.
func (m *UserMutation) ResetIsSuperuser() {
	m.is_superuser = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *UserMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *UserMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddAuthTokenIDs adds the "auth_tokens" edge to the AuthTokens entity by ids.
func (m *UserMutation) AddAuthTokenIDs(ids ...uuid.UUID) {
	if m.auth_tokens == nil {
		m.auth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.auth_tokens[ids[i]] = struct{}{}
	}
}

// ClearAuthTokens clears the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) ClearAuthTokens() {
	m.clearedauth_tokens = true
}

// AuthTokensCleared reports if the "auth_tokens" edge to the AuthTokens entity was cleared.
func (m *UserMutation) AuthTokensCleared() bool {
	return m.clearedauth_tokens
}

// RemoveAuthTokenIDs removes the "auth_tokens" edge to the AuthTokens entity by IDs.
func (m *UserMutation) RemoveAuthTokenIDs(ids ...uuid.UUID) {
	if m.removedauth_tokens == nil {
		m.removedauth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.auth_tokens, ids[i])
		m.removedauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAuthTokens returns the removed IDs of the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) RemovedAuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedauth_tokens {
		ids = append(ids, id)
	}
	return
}

// AuthTokensIDs returns the "auth_tokens" edge IDs in the mutation.
func (m *UserMutation) AuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.auth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAuthTokens resets all changes to the "auth_tokens" edge.
func (m *UserMutation) ResetAuthTokens() {
	m.auth_tokens = nil
	m.clearedauth_tokens = false
	m.removedauth_tokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_superuser != nil {
		fields = append(fields, user.FieldIsSuperuser)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsSuperuser:
		return m.IsSuperuser()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsSuperuser:
		return m.OldIsSuperuser(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsSuperuser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperuser(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsSuperuser:
		m.ResetIsSuperuser()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, user.EdgeGroup)
	}
	if m.auth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.auth_tokens))
		for id := range m.auth_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedauth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.removedauth_tokens))
		for id := range m.removedauth_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, user.EdgeGroup)
	}
	if m.clearedauth_tokens {
		edges = append(edges, user.EdgeAuthTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGroup:
		return m.clearedgroup
	case user.EdgeAuthTokens:
		return m.clearedauth_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ResetGroup()
		return nil
	case user.EdgeAuthTokens:
		m.ResetAuthTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
