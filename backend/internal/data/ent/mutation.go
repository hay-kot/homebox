// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/hay-kot/homebox/backend/internal/data/ent/attachment"
	"github.com/hay-kot/homebox/backend/internal/data/ent/authroles"
	"github.com/hay-kot/homebox/backend/internal/data/ent/authtokens"
	"github.com/hay-kot/homebox/backend/internal/data/ent/document"
	"github.com/hay-kot/homebox/backend/internal/data/ent/group"
	"github.com/hay-kot/homebox/backend/internal/data/ent/groupinvitationtoken"
	"github.com/hay-kot/homebox/backend/internal/data/ent/item"
	"github.com/hay-kot/homebox/backend/internal/data/ent/itemfield"
	"github.com/hay-kot/homebox/backend/internal/data/ent/label"
	"github.com/hay-kot/homebox/backend/internal/data/ent/location"
	"github.com/hay-kot/homebox/backend/internal/data/ent/maintenanceentry"
	"github.com/hay-kot/homebox/backend/internal/data/ent/notifier"
	"github.com/hay-kot/homebox/backend/internal/data/ent/predicate"
	"github.com/hay-kot/homebox/backend/internal/data/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment           = "Attachment"
	TypeAuthRoles            = "AuthRoles"
	TypeAuthTokens           = "AuthTokens"
	TypeDocument             = "Document"
	TypeGroup                = "Group"
	TypeGroupInvitationToken = "GroupInvitationToken"
	TypeItem                 = "Item"
	TypeItemField            = "ItemField"
	TypeLabel                = "Label"
	TypeLocation             = "Location"
	TypeMaintenanceEntry     = "MaintenanceEntry"
	TypeNotifier             = "Notifier"
	TypeUser                 = "User"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_type           *attachment.Type
	primary         *bool
	clearedFields   map[string]struct{}
	item            *uuid.UUID
	cleareditem     bool
	document        *uuid.UUID
	cleareddocument bool
	done            bool
	oldValue        func(context.Context) (*Attachment, error)
	predicates      []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *AttachmentMutation) SetType(a attachment.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttachmentMutation) GetType() (r attachment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldType(ctx context.Context) (v attachment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AttachmentMutation) ResetType() {
	m._type = nil
}

// SetPrimary sets the "primary" field.
func (m *AttachmentMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *AttachmentMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *AttachmentMutation) ResetPrimary() {
	m.primary = nil
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *AttachmentMutation) SetItemID(id uuid.UUID) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *AttachmentMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *AttachmentMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *AttachmentMutation) ItemID() (id uuid.UUID, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *AttachmentMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetDocumentID sets the "document" edge to the Document entity by id.
func (m *AttachmentMutation) SetDocumentID(id uuid.UUID) {
	m.document = &id
}

// ClearDocument clears the "document" edge to the Document entity.
func (m *AttachmentMutation) ClearDocument() {
	m.cleareddocument = true
}

// DocumentCleared reports if the "document" edge to the Document entity was cleared.
func (m *AttachmentMutation) DocumentCleared() bool {
	return m.cleareddocument
}

// DocumentID returns the "document" edge ID in the mutation.
func (m *AttachmentMutation) DocumentID() (id uuid.UUID, exists bool) {
	if m.document != nil {
		return *m.document, true
	}
	return
}

// DocumentIDs returns the "document" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) DocumentIDs() (ids []uuid.UUID) {
	if id := m.document; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocument resets all changes to the "document" edge.
func (m *AttachmentMutation) ResetDocument() {
	m.document = nil
	m.cleareddocument = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, attachment.FieldType)
	}
	if m.primary != nil {
		fields = append(fields, attachment.FieldPrimary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldType:
		return m.GetType()
	case attachment.FieldPrimary:
		return m.Primary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldType:
		return m.OldType(ctx)
	case attachment.FieldPrimary:
		return m.OldPrimary(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldType:
		v, ok := value.(attachment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attachment.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldType:
		m.ResetType()
		return nil
	case attachment.FieldPrimary:
		m.ResetPrimary()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, attachment.EdgeItem)
	}
	if m.document != nil {
		edges = append(edges, attachment.EdgeDocument)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeDocument:
		if id := m.document; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, attachment.EdgeItem)
	}
	if m.cleareddocument {
		edges = append(edges, attachment.EdgeDocument)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeItem:
		return m.cleareditem
	case attachment.EdgeDocument:
		return m.cleareddocument
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeItem:
		m.ClearItem()
		return nil
	case attachment.EdgeDocument:
		m.ClearDocument()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeItem:
		m.ResetItem()
		return nil
	case attachment.EdgeDocument:
		m.ResetDocument()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuthRolesMutation represents an operation that mutates the AuthRoles nodes in the graph.
type AuthRolesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role          *authroles.Role
	clearedFields map[string]struct{}
	token         *uuid.UUID
	clearedtoken  bool
	done          bool
	oldValue      func(context.Context) (*AuthRoles, error)
	predicates    []predicate.AuthRoles
}

var _ ent.Mutation = (*AuthRolesMutation)(nil)

// authrolesOption allows management of the mutation configuration using functional options.
type authrolesOption func(*AuthRolesMutation)

// newAuthRolesMutation creates new mutation for the AuthRoles entity.
func newAuthRolesMutation(c config, op Op, opts ...authrolesOption) *AuthRolesMutation {
	m := &AuthRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRolesID sets the ID field of the mutation.
func withAuthRolesID(id int) authrolesOption {
	return func(m *AuthRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRoles
		)
		m.oldValue = func(ctx context.Context) (*AuthRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRoles sets the old AuthRoles of the mutation.
func withAuthRoles(node *AuthRoles) authrolesOption {
	return func(m *AuthRolesMutation) {
		m.oldValue = func(context.Context) (*AuthRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRolesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRolesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *AuthRolesMutation) SetRole(a authroles.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AuthRolesMutation) Role() (r authroles.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AuthRoles entity.
// If the AuthRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRolesMutation) OldRole(ctx context.Context) (v authroles.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AuthRolesMutation) ResetRole() {
	m.role = nil
}

// SetTokenID sets the "token" edge to the AuthTokens entity by id.
func (m *AuthRolesMutation) SetTokenID(id uuid.UUID) {
	m.token = &id
}

// ClearToken clears the "token" edge to the AuthTokens entity.
func (m *AuthRolesMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the AuthTokens entity was cleared.
func (m *AuthRolesMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *AuthRolesMutation) TokenID() (id uuid.UUID, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *AuthRolesMutation) TokenIDs() (ids []uuid.UUID) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *AuthRolesMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// Where appends a list predicates to the AuthRolesMutation builder.
func (m *AuthRolesMutation) Where(ps ...predicate.AuthRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthRoles).
func (m *AuthRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRolesMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, authroles.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authroles.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authroles.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authroles.FieldRole:
		v, ok := value.(authroles.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRolesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRolesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRolesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRolesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRolesMutation) ResetField(name string) error {
	switch name {
	case authroles.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token != nil {
		edges = append(edges, authroles.EdgeToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRolesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authroles.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken {
		edges = append(edges, authroles.EdgeToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRolesMutation) EdgeCleared(name string) bool {
	switch name {
	case authroles.EdgeToken:
		return m.clearedtoken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRolesMutation) ClearEdge(name string) error {
	switch name {
	case authroles.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRolesMutation) ResetEdge(name string) error {
	switch name {
	case authroles.EdgeToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles edge %s", name)
}

// AuthTokensMutation represents an operation that mutates the AuthTokens nodes in the graph.
type AuthTokensMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	token         *[]byte
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	roles         *int
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*AuthTokens, error)
	predicates    []predicate.AuthTokens
}

var _ ent.Mutation = (*AuthTokensMutation)(nil)

// authtokensOption allows management of the mutation configuration using functional options.
type authtokensOption func(*AuthTokensMutation)

// newAuthTokensMutation creates new mutation for the AuthTokens entity.
func newAuthTokensMutation(c config, op Op, opts ...authtokensOption) *AuthTokensMutation {
	m := &AuthTokensMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthTokens,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokensID sets the ID field of the mutation.
func withAuthTokensID(id uuid.UUID) authtokensOption {
	return func(m *AuthTokensMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthTokens
		)
		m.oldValue = func(ctx context.Context) (*AuthTokens, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthTokens.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthTokens sets the old AuthTokens of the mutation.
func withAuthTokens(node *AuthTokens) authtokensOption {
	return func(m *AuthTokensMutation) {
		m.oldValue = func(context.Context) (*AuthTokens, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokensMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokensMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthTokens entities.
func (m *AuthTokensMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokensMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokensMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthTokens.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTokensMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTokensMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTokensMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthTokensMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthTokensMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthTokensMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *AuthTokensMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthTokensMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthTokensMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthTokensMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthTokensMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthTokensMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuthTokensMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthTokensMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthTokensMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuthTokensMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthTokensMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthTokensMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRolesID sets the "roles" edge to the AuthRoles entity by id.
func (m *AuthTokensMutation) SetRolesID(id int) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the AuthRoles entity.
func (m *AuthTokensMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AuthRoles entity was cleared.
func (m *AuthTokensMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *AuthTokensMutation) RolesID() (id int, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *AuthTokensMutation) RolesIDs() (ids []int) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AuthTokensMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// Where appends a list predicates to the AuthTokensMutation builder.
func (m *AuthTokensMutation) Where(ps ...predicate.AuthTokens) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokensMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokensMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthTokens, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokensMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokensMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthTokens).
func (m *AuthTokensMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokensMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, authtokens.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authtokens.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, authtokens.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, authtokens.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokensMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.CreatedAt()
	case authtokens.FieldUpdatedAt:
		return m.UpdatedAt()
	case authtokens.FieldToken:
		return m.Token()
	case authtokens.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokensMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authtokens.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authtokens.FieldToken:
		return m.OldToken(ctx)
	case authtokens.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthTokens field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtokens.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authtokens.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authtokens.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authtokens.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokensMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokensMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthTokens numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokensMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokensMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokensMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthTokens nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokensMutation) ResetField(name string) error {
	switch name {
	case authtokens.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authtokens.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authtokens.FieldToken:
		m.ResetToken()
		return nil
	case authtokens.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokensMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, authtokens.EdgeUser)
	}
	if m.roles != nil {
		edges = append(edges, authtokens.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokensMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtokens.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case authtokens.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokensMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokensMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokensMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, authtokens.EdgeUser)
	}
	if m.clearedroles {
		edges = append(edges, authtokens.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokensMutation) EdgeCleared(name string) bool {
	switch name {
	case authtokens.EdgeUser:
		return m.cleareduser
	case authtokens.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokensMutation) ClearEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ClearUser()
		return nil
	case authtokens.EdgeRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokensMutation) ResetEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ResetUser()
		return nil
	case authtokens.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	title              *string
	_path              *string
	clearedFields      map[string]struct{}
	group              *uuid.UUID
	clearedgroup       bool
	attachments        map[uuid.UUID]struct{}
	removedattachments map[uuid.UUID]struct{}
	clearedattachments bool
	done               bool
	oldValue           func(context.Context) (*Document, error)
	predicates         []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id uuid.UUID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *DocumentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DocumentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DocumentMutation) ResetTitle() {
	m.title = nil
}

// SetPath sets the "path" field.
func (m *DocumentMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *DocumentMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *DocumentMutation) ResetPath() {
	m._path = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *DocumentMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *DocumentMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *DocumentMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *DocumentMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *DocumentMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *DocumentMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *DocumentMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *DocumentMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *DocumentMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *DocumentMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *DocumentMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *DocumentMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, document.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, document.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, document.FieldTitle)
	}
	if m._path != nil {
		fields = append(fields, document.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldCreatedAt:
		return m.CreatedAt()
	case document.FieldUpdatedAt:
		return m.UpdatedAt()
	case document.FieldTitle:
		return m.Title()
	case document.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case document.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case document.FieldTitle:
		return m.OldTitle(ctx)
	case document.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case document.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case document.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case document.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case document.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case document.FieldTitle:
		m.ResetTitle()
		return nil
	case document.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, document.EdgeGroup)
	}
	if m.attachments != nil {
		edges = append(edges, document.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattachments != nil {
		edges = append(edges, document.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, document.EdgeGroup)
	}
	if m.clearedattachments {
		edges = append(edges, document.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeGroup:
		return m.clearedgroup
	case document.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeGroup:
		m.ResetGroup()
		return nil
	case document.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	name                     *string
	currency                 *group.Currency
	clearedFields            map[string]struct{}
	users                    map[uuid.UUID]struct{}
	removedusers             map[uuid.UUID]struct{}
	clearedusers             bool
	locations                map[uuid.UUID]struct{}
	removedlocations         map[uuid.UUID]struct{}
	clearedlocations         bool
	items                    map[uuid.UUID]struct{}
	removeditems             map[uuid.UUID]struct{}
	cleareditems             bool
	labels                   map[uuid.UUID]struct{}
	removedlabels            map[uuid.UUID]struct{}
	clearedlabels            bool
	documents                map[uuid.UUID]struct{}
	removeddocuments         map[uuid.UUID]struct{}
	cleareddocuments         bool
	invitation_tokens        map[uuid.UUID]struct{}
	removedinvitation_tokens map[uuid.UUID]struct{}
	clearedinvitation_tokens bool
	notifiers                map[uuid.UUID]struct{}
	removednotifiers         map[uuid.UUID]struct{}
	clearednotifiers         bool
	done                     bool
	oldValue                 func(context.Context) (*Group, error)
	predicates               []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id uuid.UUID) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetCurrency sets the "currency" field.
func (m *GroupMutation) SetCurrency(gr group.Currency) {
	m.currency = &gr
}

// Currency returns the value of the "currency" field in the mutation.
func (m *GroupMutation) Currency() (r group.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCurrency(ctx context.Context) (v group.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *GroupMutation) ResetCurrency() {
	m.currency = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *GroupMutation) AddLocationIDs(ids ...uuid.UUID) {
	if m.locations == nil {
		m.locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *GroupMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *GroupMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *GroupMutation) RemoveLocationIDs(ids ...uuid.UUID) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *GroupMutation) RemovedLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *GroupMutation) LocationsIDs() (ids []uuid.UUID) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *GroupMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *GroupMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *GroupMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *GroupMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *GroupMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *GroupMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *GroupMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *GroupMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddLabelIDs adds the "labels" edge to the Label entity by ids.
func (m *GroupMutation) AddLabelIDs(ids ...uuid.UUID) {
	if m.labels == nil {
		m.labels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.labels[ids[i]] = struct{}{}
	}
}

// ClearLabels clears the "labels" edge to the Label entity.
func (m *GroupMutation) ClearLabels() {
	m.clearedlabels = true
}

// LabelsCleared reports if the "labels" edge to the Label entity was cleared.
func (m *GroupMutation) LabelsCleared() bool {
	return m.clearedlabels
}

// RemoveLabelIDs removes the "labels" edge to the Label entity by IDs.
func (m *GroupMutation) RemoveLabelIDs(ids ...uuid.UUID) {
	if m.removedlabels == nil {
		m.removedlabels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.labels, ids[i])
		m.removedlabels[ids[i]] = struct{}{}
	}
}

// RemovedLabels returns the removed IDs of the "labels" edge to the Label entity.
func (m *GroupMutation) RemovedLabelsIDs() (ids []uuid.UUID) {
	for id := range m.removedlabels {
		ids = append(ids, id)
	}
	return
}

// LabelsIDs returns the "labels" edge IDs in the mutation.
func (m *GroupMutation) LabelsIDs() (ids []uuid.UUID) {
	for id := range m.labels {
		ids = append(ids, id)
	}
	return
}

// ResetLabels resets all changes to the "labels" edge.
func (m *GroupMutation) ResetLabels() {
	m.labels = nil
	m.clearedlabels = false
	m.removedlabels = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *GroupMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *GroupMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *GroupMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *GroupMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *GroupMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *GroupMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *GroupMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddInvitationTokenIDs adds the "invitation_tokens" edge to the GroupInvitationToken entity by ids.
func (m *GroupMutation) AddInvitationTokenIDs(ids ...uuid.UUID) {
	if m.invitation_tokens == nil {
		m.invitation_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_tokens[ids[i]] = struct{}{}
	}
}

// ClearInvitationTokens clears the "invitation_tokens" edge to the GroupInvitationToken entity.
func (m *GroupMutation) ClearInvitationTokens() {
	m.clearedinvitation_tokens = true
}

// InvitationTokensCleared reports if the "invitation_tokens" edge to the GroupInvitationToken entity was cleared.
func (m *GroupMutation) InvitationTokensCleared() bool {
	return m.clearedinvitation_tokens
}

// RemoveInvitationTokenIDs removes the "invitation_tokens" edge to the GroupInvitationToken entity by IDs.
func (m *GroupMutation) RemoveInvitationTokenIDs(ids ...uuid.UUID) {
	if m.removedinvitation_tokens == nil {
		m.removedinvitation_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_tokens, ids[i])
		m.removedinvitation_tokens[ids[i]] = struct{}{}
	}
}

// RemovedInvitationTokens returns the removed IDs of the "invitation_tokens" edge to the GroupInvitationToken entity.
func (m *GroupMutation) RemovedInvitationTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_tokens {
		ids = append(ids, id)
	}
	return
}

// InvitationTokensIDs returns the "invitation_tokens" edge IDs in the mutation.
func (m *GroupMutation) InvitationTokensIDs() (ids []uuid.UUID) {
	for id := range m.invitation_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationTokens resets all changes to the "invitation_tokens" edge.
func (m *GroupMutation) ResetInvitationTokens() {
	m.invitation_tokens = nil
	m.clearedinvitation_tokens = false
	m.removedinvitation_tokens = nil
}

// AddNotifierIDs adds the "notifiers" edge to the Notifier entity by ids.
func (m *GroupMutation) AddNotifierIDs(ids ...uuid.UUID) {
	if m.notifiers == nil {
		m.notifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifiers[ids[i]] = struct{}{}
	}
}

// ClearNotifiers clears the "notifiers" edge to the Notifier entity.
func (m *GroupMutation) ClearNotifiers() {
	m.clearednotifiers = true
}

// NotifiersCleared reports if the "notifiers" edge to the Notifier entity was cleared.
func (m *GroupMutation) NotifiersCleared() bool {
	return m.clearednotifiers
}

// RemoveNotifierIDs removes the "notifiers" edge to the Notifier entity by IDs.
func (m *GroupMutation) RemoveNotifierIDs(ids ...uuid.UUID) {
	if m.removednotifiers == nil {
		m.removednotifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifiers, ids[i])
		m.removednotifiers[ids[i]] = struct{}{}
	}
}

// RemovedNotifiers returns the removed IDs of the "notifiers" edge to the Notifier entity.
func (m *GroupMutation) RemovedNotifiersIDs() (ids []uuid.UUID) {
	for id := range m.removednotifiers {
		ids = append(ids, id)
	}
	return
}

// NotifiersIDs returns the "notifiers" edge IDs in the mutation.
func (m *GroupMutation) NotifiersIDs() (ids []uuid.UUID) {
	for id := range m.notifiers {
		ids = append(ids, id)
	}
	return
}

// ResetNotifiers resets all changes to the "notifiers" edge.
func (m *GroupMutation) ResetNotifiers() {
	m.notifiers = nil
	m.clearednotifiers = false
	m.removednotifiers = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.currency != nil {
		fields = append(fields, group.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldCurrency:
		v, ok := value.(group.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.locations != nil {
		edges = append(edges, group.EdgeLocations)
	}
	if m.items != nil {
		edges = append(edges, group.EdgeItems)
	}
	if m.labels != nil {
		edges = append(edges, group.EdgeLabels)
	}
	if m.documents != nil {
		edges = append(edges, group.EdgeDocuments)
	}
	if m.invitation_tokens != nil {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.notifiers != nil {
		edges = append(edges, group.EdgeNotifiers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.labels))
		for id := range m.labels {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeInvitationTokens:
		ids := make([]ent.Value, 0, len(m.invitation_tokens))
		for id := range m.invitation_tokens {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.notifiers))
		for id := range m.notifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.removedlocations != nil {
		edges = append(edges, group.EdgeLocations)
	}
	if m.removeditems != nil {
		edges = append(edges, group.EdgeItems)
	}
	if m.removedlabels != nil {
		edges = append(edges, group.EdgeLabels)
	}
	if m.removeddocuments != nil {
		edges = append(edges, group.EdgeDocuments)
	}
	if m.removedinvitation_tokens != nil {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.removednotifiers != nil {
		edges = append(edges, group.EdgeNotifiers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeLabels:
		ids := make([]ent.Value, 0, len(m.removedlabels))
		for id := range m.removedlabels {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeInvitationTokens:
		ids := make([]ent.Value, 0, len(m.removedinvitation_tokens))
		for id := range m.removedinvitation_tokens {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.removednotifiers))
		for id := range m.removednotifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedlocations {
		edges = append(edges, group.EdgeLocations)
	}
	if m.cleareditems {
		edges = append(edges, group.EdgeItems)
	}
	if m.clearedlabels {
		edges = append(edges, group.EdgeLabels)
	}
	if m.cleareddocuments {
		edges = append(edges, group.EdgeDocuments)
	}
	if m.clearedinvitation_tokens {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.clearednotifiers {
		edges = append(edges, group.EdgeNotifiers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeLocations:
		return m.clearedlocations
	case group.EdgeItems:
		return m.cleareditems
	case group.EdgeLabels:
		return m.clearedlabels
	case group.EdgeDocuments:
		return m.cleareddocuments
	case group.EdgeInvitationTokens:
		return m.clearedinvitation_tokens
	case group.EdgeNotifiers:
		return m.clearednotifiers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeLocations:
		m.ResetLocations()
		return nil
	case group.EdgeItems:
		m.ResetItems()
		return nil
	case group.EdgeLabels:
		m.ResetLabels()
		return nil
	case group.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case group.EdgeInvitationTokens:
		m.ResetInvitationTokens()
		return nil
	case group.EdgeNotifiers:
		m.ResetNotifiers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupInvitationTokenMutation represents an operation that mutates the GroupInvitationToken nodes in the graph.
type GroupInvitationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	token         *[]byte
	expires_at    *time.Time
	uses          *int
	adduses       *int
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*GroupInvitationToken, error)
	predicates    []predicate.GroupInvitationToken
}

var _ ent.Mutation = (*GroupInvitationTokenMutation)(nil)

// groupinvitationtokenOption allows management of the mutation configuration using functional options.
type groupinvitationtokenOption func(*GroupInvitationTokenMutation)

// newGroupInvitationTokenMutation creates new mutation for the GroupInvitationToken entity.
func newGroupInvitationTokenMutation(c config, op Op, opts ...groupinvitationtokenOption) *GroupInvitationTokenMutation {
	m := &GroupInvitationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupInvitationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupInvitationTokenID sets the ID field of the mutation.
func withGroupInvitationTokenID(id uuid.UUID) groupinvitationtokenOption {
	return func(m *GroupInvitationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupInvitationToken
		)
		m.oldValue = func(ctx context.Context) (*GroupInvitationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupInvitationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupInvitationToken sets the old GroupInvitationToken of the mutation.
func withGroupInvitationToken(node *GroupInvitationToken) groupinvitationtokenOption {
	return func(m *GroupInvitationTokenMutation) {
		m.oldValue = func(context.Context) (*GroupInvitationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupInvitationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupInvitationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupInvitationToken entities.
func (m *GroupInvitationTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupInvitationTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupInvitationTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupInvitationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupInvitationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupInvitationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupInvitationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupInvitationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupInvitationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupInvitationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *GroupInvitationTokenMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *GroupInvitationTokenMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *GroupInvitationTokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GroupInvitationTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GroupInvitationTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GroupInvitationTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUses sets the "uses" field.
func (m *GroupInvitationTokenMutation) SetUses(i int) {
	m.uses = &i
	m.adduses = nil
}

// Uses returns the value of the "uses" field in the mutation.
func (m *GroupInvitationTokenMutation) Uses() (r int, exists bool) {
	v := m.uses
	if v == nil {
		return
	}
	return *v, true
}

// OldUses returns the old "uses" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldUses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUses: %w", err)
	}
	return oldValue.Uses, nil
}

// AddUses adds i to the "uses" field.
func (m *GroupInvitationTokenMutation) AddUses(i int) {
	if m.adduses != nil {
		*m.adduses += i
	} else {
		m.adduses = &i
	}
}

// AddedUses returns the value that was added to the "uses" field in this mutation.
func (m *GroupInvitationTokenMutation) AddedUses() (r int, exists bool) {
	v := m.adduses
	if v == nil {
		return
	}
	return *v, true
}

// ResetUses resets all changes to the "uses" field.
func (m *GroupInvitationTokenMutation) ResetUses() {
	m.uses = nil
	m.adduses = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *GroupInvitationTokenMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *GroupInvitationTokenMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *GroupInvitationTokenMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *GroupInvitationTokenMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *GroupInvitationTokenMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *GroupInvitationTokenMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the GroupInvitationTokenMutation builder.
func (m *GroupInvitationTokenMutation) Where(ps ...predicate.GroupInvitationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupInvitationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupInvitationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupInvitationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupInvitationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupInvitationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupInvitationToken).
func (m *GroupInvitationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupInvitationTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, groupinvitationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupinvitationtoken.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, groupinvitationtoken.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, groupinvitationtoken.FieldExpiresAt)
	}
	if m.uses != nil {
		fields = append(fields, groupinvitationtoken.FieldUses)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupInvitationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case groupinvitationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupinvitationtoken.FieldToken:
		return m.Token()
	case groupinvitationtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case groupinvitationtoken.FieldUses:
		return m.Uses()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupInvitationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupinvitationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupinvitationtoken.FieldToken:
		return m.OldToken(ctx)
	case groupinvitationtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case groupinvitationtoken.FieldUses:
		return m.OldUses(ctx)
	}
	return nil, fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupInvitationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupinvitationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupinvitationtoken.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case groupinvitationtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case groupinvitationtoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUses(v)
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupInvitationTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduses != nil {
		fields = append(fields, groupinvitationtoken.FieldUses)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupInvitationTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupinvitationtoken.FieldUses:
		return m.AddedUses()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupInvitationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupinvitationtoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUses(v)
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupInvitationTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupInvitationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupInvitationTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroupInvitationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupInvitationTokenMutation) ResetField(name string) error {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupinvitationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupinvitationtoken.FieldToken:
		m.ResetToken()
		return nil
	case groupinvitationtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case groupinvitationtoken.FieldUses:
		m.ResetUses()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupInvitationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, groupinvitationtoken.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupInvitationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupInvitationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupInvitationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupInvitationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, groupinvitationtoken.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupInvitationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupInvitationTokenMutation) ClearEdge(name string) error {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupInvitationTokenMutation) ResetEdge(name string) error {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	name                       *string
	description                *string
	import_ref                 *string
	notes                      *string
	quantity                   *int
	addquantity                *int
	insured                    *bool
	archived                   *bool
	asset_id                   *int
	addasset_id                *int
	serial_number              *string
	model_number               *string
	manufacturer               *string
	lifetime_warranty          *bool
	warranty_expires           *time.Time
	warranty_details           *string
	purchase_time              *time.Time
	purchase_from              *string
	purchase_price             *float64
	addpurchase_price          *float64
	sold_time                  *time.Time
	sold_to                    *string
	sold_price                 *float64
	addsold_price              *float64
	sold_notes                 *string
	clearedFields              map[string]struct{}
	group                      *uuid.UUID
	clearedgroup               bool
	parent                     *uuid.UUID
	clearedparent              bool
	children                   map[uuid.UUID]struct{}
	removedchildren            map[uuid.UUID]struct{}
	clearedchildren            bool
	label                      map[uuid.UUID]struct{}
	removedlabel               map[uuid.UUID]struct{}
	clearedlabel               bool
	location                   *uuid.UUID
	clearedlocation            bool
	fields                     map[uuid.UUID]struct{}
	removedfields              map[uuid.UUID]struct{}
	clearedfields              bool
	maintenance_entries        map[uuid.UUID]struct{}
	removedmaintenance_entries map[uuid.UUID]struct{}
	clearedmaintenance_entries bool
	attachments                map[uuid.UUID]struct{}
	removedattachments         map[uuid.UUID]struct{}
	clearedattachments         bool
	done                       bool
	oldValue                   func(context.Context) (*Item, error)
	predicates                 []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id uuid.UUID) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[item.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[item.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, item.FieldDescription)
}

// SetImportRef sets the "import_ref" field.
func (m *ItemMutation) SetImportRef(s string) {
	m.import_ref = &s
}

// ImportRef returns the value of the "import_ref" field in the mutation.
func (m *ItemMutation) ImportRef() (r string, exists bool) {
	v := m.import_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldImportRef returns the old "import_ref" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldImportRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportRef: %w", err)
	}
	return oldValue.ImportRef, nil
}

// ClearImportRef clears the value of the "import_ref" field.
func (m *ItemMutation) ClearImportRef() {
	m.import_ref = nil
	m.clearedFields[item.FieldImportRef] = struct{}{}
}

// ImportRefCleared returns if the "import_ref" field was cleared in this mutation.
func (m *ItemMutation) ImportRefCleared() bool {
	_, ok := m.clearedFields[item.FieldImportRef]
	return ok
}

// ResetImportRef resets all changes to the "import_ref" field.
func (m *ItemMutation) ResetImportRef() {
	m.import_ref = nil
	delete(m.clearedFields, item.FieldImportRef)
}

// SetNotes sets the "notes" field.
func (m *ItemMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ItemMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ItemMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[item.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ItemMutation) NotesCleared() bool {
	_, ok := m.clearedFields[item.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ItemMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, item.FieldNotes)
}

// SetQuantity sets the "quantity" field.
func (m *ItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *ItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetInsured sets the "insured" field.
func (m *ItemMutation) SetInsured(b bool) {
	m.insured = &b
}

// Insured returns the value of the "insured" field in the mutation.
func (m *ItemMutation) Insured() (r bool, exists bool) {
	v := m.insured
	if v == nil {
		return
	}
	return *v, true
}

// OldInsured returns the old "insured" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldInsured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsured: %w", err)
	}
	return oldValue.Insured, nil
}

// ResetInsured resets all changes to the "insured" field.
func (m *ItemMutation) ResetInsured() {
	m.insured = nil
}

// SetArchived sets the "archived" field.
func (m *ItemMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *ItemMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *ItemMutation) ResetArchived() {
	m.archived = nil
}

// SetAssetID sets the "asset_id" field.
func (m *ItemMutation) SetAssetID(i int) {
	m.asset_id = &i
	m.addasset_id = nil
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *ItemMutation) AssetID() (r int, exists bool) {
	v := m.asset_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldAssetID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// AddAssetID adds i to the "asset_id" field.
func (m *ItemMutation) AddAssetID(i int) {
	if m.addasset_id != nil {
		*m.addasset_id += i
	} else {
		m.addasset_id = &i
	}
}

// AddedAssetID returns the value that was added to the "asset_id" field in this mutation.
func (m *ItemMutation) AddedAssetID() (r int, exists bool) {
	v := m.addasset_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *ItemMutation) ResetAssetID() {
	m.asset_id = nil
	m.addasset_id = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *ItemMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ItemMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ItemMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[item.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ItemMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[item.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ItemMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, item.FieldSerialNumber)
}

// SetModelNumber sets the "model_number" field.
func (m *ItemMutation) SetModelNumber(s string) {
	m.model_number = &s
}

// ModelNumber returns the value of the "model_number" field in the mutation.
func (m *ItemMutation) ModelNumber() (r string, exists bool) {
	v := m.model_number
	if v == nil {
		return
	}
	return *v, true
}

// OldModelNumber returns the old "model_number" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldModelNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelNumber: %w", err)
	}
	return oldValue.ModelNumber, nil
}

// ClearModelNumber clears the value of the "model_number" field.
func (m *ItemMutation) ClearModelNumber() {
	m.model_number = nil
	m.clearedFields[item.FieldModelNumber] = struct{}{}
}

// ModelNumberCleared returns if the "model_number" field was cleared in this mutation.
func (m *ItemMutation) ModelNumberCleared() bool {
	_, ok := m.clearedFields[item.FieldModelNumber]
	return ok
}

// ResetModelNumber resets all changes to the "model_number" field.
func (m *ItemMutation) ResetModelNumber() {
	m.model_number = nil
	delete(m.clearedFields, item.FieldModelNumber)
}

// SetManufacturer sets the "manufacturer" field.
func (m *ItemMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *ItemMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *ItemMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[item.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *ItemMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[item.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *ItemMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, item.FieldManufacturer)
}

// SetLifetimeWarranty sets the "lifetime_warranty" field.
func (m *ItemMutation) SetLifetimeWarranty(b bool) {
	m.lifetime_warranty = &b
}

// LifetimeWarranty returns the value of the "lifetime_warranty" field in the mutation.
func (m *ItemMutation) LifetimeWarranty() (r bool, exists bool) {
	v := m.lifetime_warranty
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeWarranty returns the old "lifetime_warranty" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldLifetimeWarranty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeWarranty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeWarranty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeWarranty: %w", err)
	}
	return oldValue.LifetimeWarranty, nil
}

// ResetLifetimeWarranty resets all changes to the "lifetime_warranty" field.
func (m *ItemMutation) ResetLifetimeWarranty() {
	m.lifetime_warranty = nil
}

// SetWarrantyExpires sets the "warranty_expires" field.
func (m *ItemMutation) SetWarrantyExpires(t time.Time) {
	m.warranty_expires = &t
}

// WarrantyExpires returns the value of the "warranty_expires" field in the mutation.
func (m *ItemMutation) WarrantyExpires() (r time.Time, exists bool) {
	v := m.warranty_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyExpires returns the old "warranty_expires" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldWarrantyExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyExpires: %w", err)
	}
	return oldValue.WarrantyExpires, nil
}

// ClearWarrantyExpires clears the value of the "warranty_expires" field.
func (m *ItemMutation) ClearWarrantyExpires() {
	m.warranty_expires = nil
	m.clearedFields[item.FieldWarrantyExpires] = struct{}{}
}

// WarrantyExpiresCleared returns if the "warranty_expires" field was cleared in this mutation.
func (m *ItemMutation) WarrantyExpiresCleared() bool {
	_, ok := m.clearedFields[item.FieldWarrantyExpires]
	return ok
}

// ResetWarrantyExpires resets all changes to the "warranty_expires" field.
func (m *ItemMutation) ResetWarrantyExpires() {
	m.warranty_expires = nil
	delete(m.clearedFields, item.FieldWarrantyExpires)
}

// SetWarrantyDetails sets the "warranty_details" field.
func (m *ItemMutation) SetWarrantyDetails(s string) {
	m.warranty_details = &s
}

// WarrantyDetails returns the value of the "warranty_details" field in the mutation.
func (m *ItemMutation) WarrantyDetails() (r string, exists bool) {
	v := m.warranty_details
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyDetails returns the old "warranty_details" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldWarrantyDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyDetails: %w", err)
	}
	return oldValue.WarrantyDetails, nil
}

// ClearWarrantyDetails clears the value of the "warranty_details" field.
func (m *ItemMutation) ClearWarrantyDetails() {
	m.warranty_details = nil
	m.clearedFields[item.FieldWarrantyDetails] = struct{}{}
}

// WarrantyDetailsCleared returns if the "warranty_details" field was cleared in this mutation.
func (m *ItemMutation) WarrantyDetailsCleared() bool {
	_, ok := m.clearedFields[item.FieldWarrantyDetails]
	return ok
}

// ResetWarrantyDetails resets all changes to the "warranty_details" field.
func (m *ItemMutation) ResetWarrantyDetails() {
	m.warranty_details = nil
	delete(m.clearedFields, item.FieldWarrantyDetails)
}

// SetPurchaseTime sets the "purchase_time" field.
func (m *ItemMutation) SetPurchaseTime(t time.Time) {
	m.purchase_time = &t
}

// PurchaseTime returns the value of the "purchase_time" field in the mutation.
func (m *ItemMutation) PurchaseTime() (r time.Time, exists bool) {
	v := m.purchase_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseTime returns the old "purchase_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchaseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseTime: %w", err)
	}
	return oldValue.PurchaseTime, nil
}

// ClearPurchaseTime clears the value of the "purchase_time" field.
func (m *ItemMutation) ClearPurchaseTime() {
	m.purchase_time = nil
	m.clearedFields[item.FieldPurchaseTime] = struct{}{}
}

// PurchaseTimeCleared returns if the "purchase_time" field was cleared in this mutation.
func (m *ItemMutation) PurchaseTimeCleared() bool {
	_, ok := m.clearedFields[item.FieldPurchaseTime]
	return ok
}

// ResetPurchaseTime resets all changes to the "purchase_time" field.
func (m *ItemMutation) ResetPurchaseTime() {
	m.purchase_time = nil
	delete(m.clearedFields, item.FieldPurchaseTime)
}

// SetPurchaseFrom sets the "purchase_from" field.
func (m *ItemMutation) SetPurchaseFrom(s string) {
	m.purchase_from = &s
}

// PurchaseFrom returns the value of the "purchase_from" field in the mutation.
func (m *ItemMutation) PurchaseFrom() (r string, exists bool) {
	v := m.purchase_from
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseFrom returns the old "purchase_from" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchaseFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseFrom: %w", err)
	}
	return oldValue.PurchaseFrom, nil
}

// ClearPurchaseFrom clears the value of the "purchase_from" field.
func (m *ItemMutation) ClearPurchaseFrom() {
	m.purchase_from = nil
	m.clearedFields[item.FieldPurchaseFrom] = struct{}{}
}

// PurchaseFromCleared returns if the "purchase_from" field was cleared in this mutation.
func (m *ItemMutation) PurchaseFromCleared() bool {
	_, ok := m.clearedFields[item.FieldPurchaseFrom]
	return ok
}

// ResetPurchaseFrom resets all changes to the "purchase_from" field.
func (m *ItemMutation) ResetPurchaseFrom() {
	m.purchase_from = nil
	delete(m.clearedFields, item.FieldPurchaseFrom)
}

// SetPurchasePrice sets the "purchase_price" field.
func (m *ItemMutation) SetPurchasePrice(f float64) {
	m.purchase_price = &f
	m.addpurchase_price = nil
}

// PurchasePrice returns the value of the "purchase_price" field in the mutation.
func (m *ItemMutation) PurchasePrice() (r float64, exists bool) {
	v := m.purchase_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasePrice returns the old "purchase_price" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldPurchasePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasePrice: %w", err)
	}
	return oldValue.PurchasePrice, nil
}

// AddPurchasePrice adds f to the "purchase_price" field.
func (m *ItemMutation) AddPurchasePrice(f float64) {
	if m.addpurchase_price != nil {
		*m.addpurchase_price += f
	} else {
		m.addpurchase_price = &f
	}
}

// AddedPurchasePrice returns the value that was added to the "purchase_price" field in this mutation.
func (m *ItemMutation) AddedPurchasePrice() (r float64, exists bool) {
	v := m.addpurchase_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchasePrice resets all changes to the "purchase_price" field.
func (m *ItemMutation) ResetPurchasePrice() {
	m.purchase_price = nil
	m.addpurchase_price = nil
}

// SetSoldTime sets the "sold_time" field.
func (m *ItemMutation) SetSoldTime(t time.Time) {
	m.sold_time = &t
}

// SoldTime returns the value of the "sold_time" field in the mutation.
func (m *ItemMutation) SoldTime() (r time.Time, exists bool) {
	v := m.sold_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTime returns the old "sold_time" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTime: %w", err)
	}
	return oldValue.SoldTime, nil
}

// ClearSoldTime clears the value of the "sold_time" field.
func (m *ItemMutation) ClearSoldTime() {
	m.sold_time = nil
	m.clearedFields[item.FieldSoldTime] = struct{}{}
}

// SoldTimeCleared returns if the "sold_time" field was cleared in this mutation.
func (m *ItemMutation) SoldTimeCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldTime]
	return ok
}

// ResetSoldTime resets all changes to the "sold_time" field.
func (m *ItemMutation) ResetSoldTime() {
	m.sold_time = nil
	delete(m.clearedFields, item.FieldSoldTime)
}

// SetSoldTo sets the "sold_to" field.
func (m *ItemMutation) SetSoldTo(s string) {
	m.sold_to = &s
}

// SoldTo returns the value of the "sold_to" field in the mutation.
func (m *ItemMutation) SoldTo() (r string, exists bool) {
	v := m.sold_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTo returns the old "sold_to" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTo: %w", err)
	}
	return oldValue.SoldTo, nil
}

// ClearSoldTo clears the value of the "sold_to" field.
func (m *ItemMutation) ClearSoldTo() {
	m.sold_to = nil
	m.clearedFields[item.FieldSoldTo] = struct{}{}
}

// SoldToCleared returns if the "sold_to" field was cleared in this mutation.
func (m *ItemMutation) SoldToCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldTo]
	return ok
}

// ResetSoldTo resets all changes to the "sold_to" field.
func (m *ItemMutation) ResetSoldTo() {
	m.sold_to = nil
	delete(m.clearedFields, item.FieldSoldTo)
}

// SetSoldPrice sets the "sold_price" field.
func (m *ItemMutation) SetSoldPrice(f float64) {
	m.sold_price = &f
	m.addsold_price = nil
}

// SoldPrice returns the value of the "sold_price" field in the mutation.
func (m *ItemMutation) SoldPrice() (r float64, exists bool) {
	v := m.sold_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldPrice returns the old "sold_price" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldPrice: %w", err)
	}
	return oldValue.SoldPrice, nil
}

// AddSoldPrice adds f to the "sold_price" field.
func (m *ItemMutation) AddSoldPrice(f float64) {
	if m.addsold_price != nil {
		*m.addsold_price += f
	} else {
		m.addsold_price = &f
	}
}

// AddedSoldPrice returns the value that was added to the "sold_price" field in this mutation.
func (m *ItemMutation) AddedSoldPrice() (r float64, exists bool) {
	v := m.addsold_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoldPrice resets all changes to the "sold_price" field.
func (m *ItemMutation) ResetSoldPrice() {
	m.sold_price = nil
	m.addsold_price = nil
}

// SetSoldNotes sets the "sold_notes" field.
func (m *ItemMutation) SetSoldNotes(s string) {
	m.sold_notes = &s
}

// SoldNotes returns the value of the "sold_notes" field in the mutation.
func (m *ItemMutation) SoldNotes() (r string, exists bool) {
	v := m.sold_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldNotes returns the old "sold_notes" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSoldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldNotes: %w", err)
	}
	return oldValue.SoldNotes, nil
}

// ClearSoldNotes clears the value of the "sold_notes" field.
func (m *ItemMutation) ClearSoldNotes() {
	m.sold_notes = nil
	m.clearedFields[item.FieldSoldNotes] = struct{}{}
}

// SoldNotesCleared returns if the "sold_notes" field was cleared in this mutation.
func (m *ItemMutation) SoldNotesCleared() bool {
	_, ok := m.clearedFields[item.FieldSoldNotes]
	return ok
}

// ResetSoldNotes resets all changes to the "sold_notes" field.
func (m *ItemMutation) ResetSoldNotes() {
	m.sold_notes = nil
	delete(m.clearedFields, item.FieldSoldNotes)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *ItemMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *ItemMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *ItemMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *ItemMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *ItemMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetParentID sets the "parent" edge to the Item entity by id.
func (m *ItemMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Item entity.
func (m *ItemMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Item entity was cleared.
func (m *ItemMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ItemMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ItemMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Item entity by ids.
func (m *ItemMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Item entity.
func (m *ItemMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Item entity was cleared.
func (m *ItemMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Item entity by IDs.
func (m *ItemMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Item entity.
func (m *ItemMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ItemMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ItemMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddLabelIDs adds the "label" edge to the Label entity by ids.
func (m *ItemMutation) AddLabelIDs(ids ...uuid.UUID) {
	if m.label == nil {
		m.label = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.label[ids[i]] = struct{}{}
	}
}

// ClearLabel clears the "label" edge to the Label entity.
func (m *ItemMutation) ClearLabel() {
	m.clearedlabel = true
}

// LabelCleared reports if the "label" edge to the Label entity was cleared.
func (m *ItemMutation) LabelCleared() bool {
	return m.clearedlabel
}

// RemoveLabelIDs removes the "label" edge to the Label entity by IDs.
func (m *ItemMutation) RemoveLabelIDs(ids ...uuid.UUID) {
	if m.removedlabel == nil {
		m.removedlabel = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.label, ids[i])
		m.removedlabel[ids[i]] = struct{}{}
	}
}

// RemovedLabel returns the removed IDs of the "label" edge to the Label entity.
func (m *ItemMutation) RemovedLabelIDs() (ids []uuid.UUID) {
	for id := range m.removedlabel {
		ids = append(ids, id)
	}
	return
}

// LabelIDs returns the "label" edge IDs in the mutation.
func (m *ItemMutation) LabelIDs() (ids []uuid.UUID) {
	for id := range m.label {
		ids = append(ids, id)
	}
	return
}

// ResetLabel resets all changes to the "label" edge.
func (m *ItemMutation) ResetLabel() {
	m.label = nil
	m.clearedlabel = false
	m.removedlabel = nil
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ItemMutation) SetLocationID(id uuid.UUID) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ItemMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ItemMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ItemMutation) LocationID() (id uuid.UUID, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ItemMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddFieldIDs adds the "fields" edge to the ItemField entity by ids.
func (m *ItemMutation) AddFieldIDs(ids ...uuid.UUID) {
	if m.fields == nil {
		m.fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the ItemField entity.
func (m *ItemMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the ItemField entity was cleared.
func (m *ItemMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the ItemField entity by IDs.
func (m *ItemMutation) RemoveFieldIDs(ids ...uuid.UUID) {
	if m.removedfields == nil {
		m.removedfields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the ItemField entity.
func (m *ItemMutation) RemovedFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *ItemMutation) FieldsIDs() (ids []uuid.UUID) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *ItemMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// AddMaintenanceEntryIDs adds the "maintenance_entries" edge to the MaintenanceEntry entity by ids.
func (m *ItemMutation) AddMaintenanceEntryIDs(ids ...uuid.UUID) {
	if m.maintenance_entries == nil {
		m.maintenance_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.maintenance_entries[ids[i]] = struct{}{}
	}
}

// ClearMaintenanceEntries clears the "maintenance_entries" edge to the MaintenanceEntry entity.
func (m *ItemMutation) ClearMaintenanceEntries() {
	m.clearedmaintenance_entries = true
}

// MaintenanceEntriesCleared reports if the "maintenance_entries" edge to the MaintenanceEntry entity was cleared.
func (m *ItemMutation) MaintenanceEntriesCleared() bool {
	return m.clearedmaintenance_entries
}

// RemoveMaintenanceEntryIDs removes the "maintenance_entries" edge to the MaintenanceEntry entity by IDs.
func (m *ItemMutation) RemoveMaintenanceEntryIDs(ids ...uuid.UUID) {
	if m.removedmaintenance_entries == nil {
		m.removedmaintenance_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.maintenance_entries, ids[i])
		m.removedmaintenance_entries[ids[i]] = struct{}{}
	}
}

// RemovedMaintenanceEntries returns the removed IDs of the "maintenance_entries" edge to the MaintenanceEntry entity.
func (m *ItemMutation) RemovedMaintenanceEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedmaintenance_entries {
		ids = append(ids, id)
	}
	return
}

// MaintenanceEntriesIDs returns the "maintenance_entries" edge IDs in the mutation.
func (m *ItemMutation) MaintenanceEntriesIDs() (ids []uuid.UUID) {
	for id := range m.maintenance_entries {
		ids = append(ids, id)
	}
	return
}

// ResetMaintenanceEntries resets all changes to the "maintenance_entries" edge.
func (m *ItemMutation) ResetMaintenanceEntries() {
	m.maintenance_entries = nil
	m.clearedmaintenance_entries = false
	m.removedmaintenance_entries = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *ItemMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *ItemMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *ItemMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *ItemMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *ItemMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *ItemMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *ItemMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Item, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, item.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, item.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.description != nil {
		fields = append(fields, item.FieldDescription)
	}
	if m.import_ref != nil {
		fields = append(fields, item.FieldImportRef)
	}
	if m.notes != nil {
		fields = append(fields, item.FieldNotes)
	}
	if m.quantity != nil {
		fields = append(fields, item.FieldQuantity)
	}
	if m.insured != nil {
		fields = append(fields, item.FieldInsured)
	}
	if m.archived != nil {
		fields = append(fields, item.FieldArchived)
	}
	if m.asset_id != nil {
		fields = append(fields, item.FieldAssetID)
	}
	if m.serial_number != nil {
		fields = append(fields, item.FieldSerialNumber)
	}
	if m.model_number != nil {
		fields = append(fields, item.FieldModelNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, item.FieldManufacturer)
	}
	if m.lifetime_warranty != nil {
		fields = append(fields, item.FieldLifetimeWarranty)
	}
	if m.warranty_expires != nil {
		fields = append(fields, item.FieldWarrantyExpires)
	}
	if m.warranty_details != nil {
		fields = append(fields, item.FieldWarrantyDetails)
	}
	if m.purchase_time != nil {
		fields = append(fields, item.FieldPurchaseTime)
	}
	if m.purchase_from != nil {
		fields = append(fields, item.FieldPurchaseFrom)
	}
	if m.purchase_price != nil {
		fields = append(fields, item.FieldPurchasePrice)
	}
	if m.sold_time != nil {
		fields = append(fields, item.FieldSoldTime)
	}
	if m.sold_to != nil {
		fields = append(fields, item.FieldSoldTo)
	}
	if m.sold_price != nil {
		fields = append(fields, item.FieldSoldPrice)
	}
	if m.sold_notes != nil {
		fields = append(fields, item.FieldSoldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCreatedAt:
		return m.CreatedAt()
	case item.FieldUpdatedAt:
		return m.UpdatedAt()
	case item.FieldName:
		return m.Name()
	case item.FieldDescription:
		return m.Description()
	case item.FieldImportRef:
		return m.ImportRef()
	case item.FieldNotes:
		return m.Notes()
	case item.FieldQuantity:
		return m.Quantity()
	case item.FieldInsured:
		return m.Insured()
	case item.FieldArchived:
		return m.Archived()
	case item.FieldAssetID:
		return m.AssetID()
	case item.FieldSerialNumber:
		return m.SerialNumber()
	case item.FieldModelNumber:
		return m.ModelNumber()
	case item.FieldManufacturer:
		return m.Manufacturer()
	case item.FieldLifetimeWarranty:
		return m.LifetimeWarranty()
	case item.FieldWarrantyExpires:
		return m.WarrantyExpires()
	case item.FieldWarrantyDetails:
		return m.WarrantyDetails()
	case item.FieldPurchaseTime:
		return m.PurchaseTime()
	case item.FieldPurchaseFrom:
		return m.PurchaseFrom()
	case item.FieldPurchasePrice:
		return m.PurchasePrice()
	case item.FieldSoldTime:
		return m.SoldTime()
	case item.FieldSoldTo:
		return m.SoldTo()
	case item.FieldSoldPrice:
		return m.SoldPrice()
	case item.FieldSoldNotes:
		return m.SoldNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case item.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldDescription:
		return m.OldDescription(ctx)
	case item.FieldImportRef:
		return m.OldImportRef(ctx)
	case item.FieldNotes:
		return m.OldNotes(ctx)
	case item.FieldQuantity:
		return m.OldQuantity(ctx)
	case item.FieldInsured:
		return m.OldInsured(ctx)
	case item.FieldArchived:
		return m.OldArchived(ctx)
	case item.FieldAssetID:
		return m.OldAssetID(ctx)
	case item.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case item.FieldModelNumber:
		return m.OldModelNumber(ctx)
	case item.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case item.FieldLifetimeWarranty:
		return m.OldLifetimeWarranty(ctx)
	case item.FieldWarrantyExpires:
		return m.OldWarrantyExpires(ctx)
	case item.FieldWarrantyDetails:
		return m.OldWarrantyDetails(ctx)
	case item.FieldPurchaseTime:
		return m.OldPurchaseTime(ctx)
	case item.FieldPurchaseFrom:
		return m.OldPurchaseFrom(ctx)
	case item.FieldPurchasePrice:
		return m.OldPurchasePrice(ctx)
	case item.FieldSoldTime:
		return m.OldSoldTime(ctx)
	case item.FieldSoldTo:
		return m.OldSoldTo(ctx)
	case item.FieldSoldPrice:
		return m.OldSoldPrice(ctx)
	case item.FieldSoldNotes:
		return m.OldSoldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case item.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case item.FieldImportRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportRef(v)
		return nil
	case item.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case item.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case item.FieldInsured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsured(v)
		return nil
	case item.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case item.FieldAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	case item.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case item.FieldModelNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelNumber(v)
		return nil
	case item.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case item.FieldLifetimeWarranty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeWarranty(v)
		return nil
	case item.FieldWarrantyExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyExpires(v)
		return nil
	case item.FieldWarrantyDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyDetails(v)
		return nil
	case item.FieldPurchaseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseTime(v)
		return nil
	case item.FieldPurchaseFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseFrom(v)
		return nil
	case item.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasePrice(v)
		return nil
	case item.FieldSoldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTime(v)
		return nil
	case item.FieldSoldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTo(v)
		return nil
	case item.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldPrice(v)
		return nil
	case item.FieldSoldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, item.FieldQuantity)
	}
	if m.addasset_id != nil {
		fields = append(fields, item.FieldAssetID)
	}
	if m.addpurchase_price != nil {
		fields = append(fields, item.FieldPurchasePrice)
	}
	if m.addsold_price != nil {
		fields = append(fields, item.FieldSoldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldQuantity:
		return m.AddedQuantity()
	case item.FieldAssetID:
		return m.AddedAssetID()
	case item.FieldPurchasePrice:
		return m.AddedPurchasePrice()
	case item.FieldSoldPrice:
		return m.AddedSoldPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case item.FieldAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetID(v)
		return nil
	case item.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchasePrice(v)
		return nil
	case item.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoldPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldDescription) {
		fields = append(fields, item.FieldDescription)
	}
	if m.FieldCleared(item.FieldImportRef) {
		fields = append(fields, item.FieldImportRef)
	}
	if m.FieldCleared(item.FieldNotes) {
		fields = append(fields, item.FieldNotes)
	}
	if m.FieldCleared(item.FieldSerialNumber) {
		fields = append(fields, item.FieldSerialNumber)
	}
	if m.FieldCleared(item.FieldModelNumber) {
		fields = append(fields, item.FieldModelNumber)
	}
	if m.FieldCleared(item.FieldManufacturer) {
		fields = append(fields, item.FieldManufacturer)
	}
	if m.FieldCleared(item.FieldWarrantyExpires) {
		fields = append(fields, item.FieldWarrantyExpires)
	}
	if m.FieldCleared(item.FieldWarrantyDetails) {
		fields = append(fields, item.FieldWarrantyDetails)
	}
	if m.FieldCleared(item.FieldPurchaseTime) {
		fields = append(fields, item.FieldPurchaseTime)
	}
	if m.FieldCleared(item.FieldPurchaseFrom) {
		fields = append(fields, item.FieldPurchaseFrom)
	}
	if m.FieldCleared(item.FieldSoldTime) {
		fields = append(fields, item.FieldSoldTime)
	}
	if m.FieldCleared(item.FieldSoldTo) {
		fields = append(fields, item.FieldSoldTo)
	}
	if m.FieldCleared(item.FieldSoldNotes) {
		fields = append(fields, item.FieldSoldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldDescription:
		m.ClearDescription()
		return nil
	case item.FieldImportRef:
		m.ClearImportRef()
		return nil
	case item.FieldNotes:
		m.ClearNotes()
		return nil
	case item.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case item.FieldModelNumber:
		m.ClearModelNumber()
		return nil
	case item.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case item.FieldWarrantyExpires:
		m.ClearWarrantyExpires()
		return nil
	case item.FieldWarrantyDetails:
		m.ClearWarrantyDetails()
		return nil
	case item.FieldPurchaseTime:
		m.ClearPurchaseTime()
		return nil
	case item.FieldPurchaseFrom:
		m.ClearPurchaseFrom()
		return nil
	case item.FieldSoldTime:
		m.ClearSoldTime()
		return nil
	case item.FieldSoldTo:
		m.ClearSoldTo()
		return nil
	case item.FieldSoldNotes:
		m.ClearSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case item.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldDescription:
		m.ResetDescription()
		return nil
	case item.FieldImportRef:
		m.ResetImportRef()
		return nil
	case item.FieldNotes:
		m.ResetNotes()
		return nil
	case item.FieldQuantity:
		m.ResetQuantity()
		return nil
	case item.FieldInsured:
		m.ResetInsured()
		return nil
	case item.FieldArchived:
		m.ResetArchived()
		return nil
	case item.FieldAssetID:
		m.ResetAssetID()
		return nil
	case item.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case item.FieldModelNumber:
		m.ResetModelNumber()
		return nil
	case item.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case item.FieldLifetimeWarranty:
		m.ResetLifetimeWarranty()
		return nil
	case item.FieldWarrantyExpires:
		m.ResetWarrantyExpires()
		return nil
	case item.FieldWarrantyDetails:
		m.ResetWarrantyDetails()
		return nil
	case item.FieldPurchaseTime:
		m.ResetPurchaseTime()
		return nil
	case item.FieldPurchaseFrom:
		m.ResetPurchaseFrom()
		return nil
	case item.FieldPurchasePrice:
		m.ResetPurchasePrice()
		return nil
	case item.FieldSoldTime:
		m.ResetSoldTime()
		return nil
	case item.FieldSoldTo:
		m.ResetSoldTo()
		return nil
	case item.FieldSoldPrice:
		m.ResetSoldPrice()
		return nil
	case item.FieldSoldNotes:
		m.ResetSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.group != nil {
		edges = append(edges, item.EdgeGroup)
	}
	if m.parent != nil {
		edges = append(edges, item.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, item.EdgeChildren)
	}
	if m.label != nil {
		edges = append(edges, item.EdgeLabel)
	}
	if m.location != nil {
		edges = append(edges, item.EdgeLocation)
	}
	if m.fields != nil {
		edges = append(edges, item.EdgeFields)
	}
	if m.maintenance_entries != nil {
		edges = append(edges, item.EdgeMaintenanceEntries)
	}
	if m.attachments != nil {
		edges = append(edges, item.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.label))
		for id := range m.label {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeMaintenanceEntries:
		ids := make([]ent.Value, 0, len(m.maintenance_entries))
		for id := range m.maintenance_entries {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedchildren != nil {
		edges = append(edges, item.EdgeChildren)
	}
	if m.removedlabel != nil {
		edges = append(edges, item.EdgeLabel)
	}
	if m.removedfields != nil {
		edges = append(edges, item.EdgeFields)
	}
	if m.removedmaintenance_entries != nil {
		edges = append(edges, item.EdgeMaintenanceEntries)
	}
	if m.removedattachments != nil {
		edges = append(edges, item.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.removedlabel))
		for id := range m.removedlabel {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeMaintenanceEntries:
		ids := make([]ent.Value, 0, len(m.removedmaintenance_entries))
		for id := range m.removedmaintenance_entries {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedgroup {
		edges = append(edges, item.EdgeGroup)
	}
	if m.clearedparent {
		edges = append(edges, item.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, item.EdgeChildren)
	}
	if m.clearedlabel {
		edges = append(edges, item.EdgeLabel)
	}
	if m.clearedlocation {
		edges = append(edges, item.EdgeLocation)
	}
	if m.clearedfields {
		edges = append(edges, item.EdgeFields)
	}
	if m.clearedmaintenance_entries {
		edges = append(edges, item.EdgeMaintenanceEntries)
	}
	if m.clearedattachments {
		edges = append(edges, item.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeGroup:
		return m.clearedgroup
	case item.EdgeParent:
		return m.clearedparent
	case item.EdgeChildren:
		return m.clearedchildren
	case item.EdgeLabel:
		return m.clearedlabel
	case item.EdgeLocation:
		return m.clearedlocation
	case item.EdgeFields:
		return m.clearedfields
	case item.EdgeMaintenanceEntries:
		return m.clearedmaintenance_entries
	case item.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	case item.EdgeGroup:
		m.ClearGroup()
		return nil
	case item.EdgeParent:
		m.ClearParent()
		return nil
	case item.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeGroup:
		m.ResetGroup()
		return nil
	case item.EdgeParent:
		m.ResetParent()
		return nil
	case item.EdgeChildren:
		m.ResetChildren()
		return nil
	case item.EdgeLabel:
		m.ResetLabel()
		return nil
	case item.EdgeLocation:
		m.ResetLocation()
		return nil
	case item.EdgeFields:
		m.ResetFields()
		return nil
	case item.EdgeMaintenanceEntries:
		m.ResetMaintenanceEntries()
		return nil
	case item.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// ItemFieldMutation represents an operation that mutates the ItemField nodes in the graph.
type ItemFieldMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	_type           *itemfield.Type
	text_value      *string
	number_value    *int
	addnumber_value *int
	boolean_value   *bool
	time_value      *time.Time
	clearedFields   map[string]struct{}
	item            *uuid.UUID
	cleareditem     bool
	done            bool
	oldValue        func(context.Context) (*ItemField, error)
	predicates      []predicate.ItemField
}

var _ ent.Mutation = (*ItemFieldMutation)(nil)

// itemfieldOption allows management of the mutation configuration using functional options.
type itemfieldOption func(*ItemFieldMutation)

// newItemFieldMutation creates new mutation for the ItemField entity.
func newItemFieldMutation(c config, op Op, opts ...itemfieldOption) *ItemFieldMutation {
	m := &ItemFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeItemField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemFieldID sets the ID field of the mutation.
func withItemFieldID(id uuid.UUID) itemfieldOption {
	return func(m *ItemFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *ItemField
		)
		m.oldValue = func(ctx context.Context) (*ItemField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ItemField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItemField sets the old ItemField of the mutation.
func withItemField(node *ItemField) itemfieldOption {
	return func(m *ItemFieldMutation) {
		m.oldValue = func(context.Context) (*ItemField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ItemField entities.
func (m *ItemFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ItemField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemFieldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemFieldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemFieldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemFieldMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemFieldMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemFieldMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemFieldMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemFieldMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemFieldMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemFieldMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[itemfield.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemFieldMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemFieldMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, itemfield.FieldDescription)
}

// SetType sets the "type" field.
func (m *ItemFieldMutation) SetType(i itemfield.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemFieldMutation) GetType() (r itemfield.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldType(ctx context.Context) (v itemfield.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemFieldMutation) ResetType() {
	m._type = nil
}

// SetTextValue sets the "text_value" field.
func (m *ItemFieldMutation) SetTextValue(s string) {
	m.text_value = &s
}

// TextValue returns the value of the "text_value" field in the mutation.
func (m *ItemFieldMutation) TextValue() (r string, exists bool) {
	v := m.text_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTextValue returns the old "text_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldTextValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextValue: %w", err)
	}
	return oldValue.TextValue, nil
}

// ClearTextValue clears the value of the "text_value" field.
func (m *ItemFieldMutation) ClearTextValue() {
	m.text_value = nil
	m.clearedFields[itemfield.FieldTextValue] = struct{}{}
}

// TextValueCleared returns if the "text_value" field was cleared in this mutation.
func (m *ItemFieldMutation) TextValueCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldTextValue]
	return ok
}

// ResetTextValue resets all changes to the "text_value" field.
func (m *ItemFieldMutation) ResetTextValue() {
	m.text_value = nil
	delete(m.clearedFields, itemfield.FieldTextValue)
}

// SetNumberValue sets the "number_value" field.
func (m *ItemFieldMutation) SetNumberValue(i int) {
	m.number_value = &i
	m.addnumber_value = nil
}

// NumberValue returns the value of the "number_value" field in the mutation.
func (m *ItemFieldMutation) NumberValue() (r int, exists bool) {
	v := m.number_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberValue returns the old "number_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldNumberValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberValue: %w", err)
	}
	return oldValue.NumberValue, nil
}

// AddNumberValue adds i to the "number_value" field.
func (m *ItemFieldMutation) AddNumberValue(i int) {
	if m.addnumber_value != nil {
		*m.addnumber_value += i
	} else {
		m.addnumber_value = &i
	}
}

// AddedNumberValue returns the value that was added to the "number_value" field in this mutation.
func (m *ItemFieldMutation) AddedNumberValue() (r int, exists bool) {
	v := m.addnumber_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberValue clears the value of the "number_value" field.
func (m *ItemFieldMutation) ClearNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	m.clearedFields[itemfield.FieldNumberValue] = struct{}{}
}

// NumberValueCleared returns if the "number_value" field was cleared in this mutation.
func (m *ItemFieldMutation) NumberValueCleared() bool {
	_, ok := m.clearedFields[itemfield.FieldNumberValue]
	return ok
}

// ResetNumberValue resets all changes to the "number_value" field.
func (m *ItemFieldMutation) ResetNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	delete(m.clearedFields, itemfield.FieldNumberValue)
}

// SetBooleanValue sets the "boolean_value" field.
func (m *ItemFieldMutation) SetBooleanValue(b bool) {
	m.boolean_value = &b
}

// BooleanValue returns the value of the "boolean_value" field in the mutation.
func (m *ItemFieldMutation) BooleanValue() (r bool, exists bool) {
	v := m.boolean_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBooleanValue returns the old "boolean_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldBooleanValue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBooleanValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBooleanValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBooleanValue: %w", err)
	}
	return oldValue.BooleanValue, nil
}

// ResetBooleanValue resets all changes to the "boolean_value" field.
func (m *ItemFieldMutation) ResetBooleanValue() {
	m.boolean_value = nil
}

// SetTimeValue sets the "time_value" field.
func (m *ItemFieldMutation) SetTimeValue(t time.Time) {
	m.time_value = &t
}

// TimeValue returns the value of the "time_value" field in the mutation.
func (m *ItemFieldMutation) TimeValue() (r time.Time, exists bool) {
	v := m.time_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeValue returns the old "time_value" field's value of the ItemField entity.
// If the ItemField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemFieldMutation) OldTimeValue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeValue: %w", err)
	}
	return oldValue.TimeValue, nil
}

// ResetTimeValue resets all changes to the "time_value" field.
func (m *ItemFieldMutation) ResetTimeValue() {
	m.time_value = nil
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *ItemFieldMutation) SetItemID(id uuid.UUID) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *ItemFieldMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *ItemFieldMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *ItemFieldMutation) ItemID() (id uuid.UUID, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *ItemFieldMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *ItemFieldMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the ItemFieldMutation builder.
func (m *ItemFieldMutation) Where(ps ...predicate.ItemField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ItemFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ItemFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ItemField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ItemFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ItemFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ItemField).
func (m *ItemFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemFieldMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, itemfield.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, itemfield.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, itemfield.FieldName)
	}
	if m.description != nil {
		fields = append(fields, itemfield.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, itemfield.FieldType)
	}
	if m.text_value != nil {
		fields = append(fields, itemfield.FieldTextValue)
	}
	if m.number_value != nil {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	if m.boolean_value != nil {
		fields = append(fields, itemfield.FieldBooleanValue)
	}
	if m.time_value != nil {
		fields = append(fields, itemfield.FieldTimeValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itemfield.FieldCreatedAt:
		return m.CreatedAt()
	case itemfield.FieldUpdatedAt:
		return m.UpdatedAt()
	case itemfield.FieldName:
		return m.Name()
	case itemfield.FieldDescription:
		return m.Description()
	case itemfield.FieldType:
		return m.GetType()
	case itemfield.FieldTextValue:
		return m.TextValue()
	case itemfield.FieldNumberValue:
		return m.NumberValue()
	case itemfield.FieldBooleanValue:
		return m.BooleanValue()
	case itemfield.FieldTimeValue:
		return m.TimeValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itemfield.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case itemfield.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case itemfield.FieldName:
		return m.OldName(ctx)
	case itemfield.FieldDescription:
		return m.OldDescription(ctx)
	case itemfield.FieldType:
		return m.OldType(ctx)
	case itemfield.FieldTextValue:
		return m.OldTextValue(ctx)
	case itemfield.FieldNumberValue:
		return m.OldNumberValue(ctx)
	case itemfield.FieldBooleanValue:
		return m.OldBooleanValue(ctx)
	case itemfield.FieldTimeValue:
		return m.OldTimeValue(ctx)
	}
	return nil, fmt.Errorf("unknown ItemField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itemfield.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case itemfield.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case itemfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case itemfield.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case itemfield.FieldType:
		v, ok := value.(itemfield.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case itemfield.FieldTextValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextValue(v)
		return nil
	case itemfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberValue(v)
		return nil
	case itemfield.FieldBooleanValue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBooleanValue(v)
		return nil
	case itemfield.FieldTimeValue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeValue(v)
		return nil
	}
	return fmt.Errorf("unknown ItemField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemFieldMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_value != nil {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case itemfield.FieldNumberValue:
		return m.AddedNumberValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case itemfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberValue(v)
		return nil
	}
	return fmt.Errorf("unknown ItemField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(itemfield.FieldDescription) {
		fields = append(fields, itemfield.FieldDescription)
	}
	if m.FieldCleared(itemfield.FieldTextValue) {
		fields = append(fields, itemfield.FieldTextValue)
	}
	if m.FieldCleared(itemfield.FieldNumberValue) {
		fields = append(fields, itemfield.FieldNumberValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemFieldMutation) ClearField(name string) error {
	switch name {
	case itemfield.FieldDescription:
		m.ClearDescription()
		return nil
	case itemfield.FieldTextValue:
		m.ClearTextValue()
		return nil
	case itemfield.FieldNumberValue:
		m.ClearNumberValue()
		return nil
	}
	return fmt.Errorf("unknown ItemField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemFieldMutation) ResetField(name string) error {
	switch name {
	case itemfield.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case itemfield.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case itemfield.FieldName:
		m.ResetName()
		return nil
	case itemfield.FieldDescription:
		m.ResetDescription()
		return nil
	case itemfield.FieldType:
		m.ResetType()
		return nil
	case itemfield.FieldTextValue:
		m.ResetTextValue()
		return nil
	case itemfield.FieldNumberValue:
		m.ResetNumberValue()
		return nil
	case itemfield.FieldBooleanValue:
		m.ResetBooleanValue()
		return nil
	case itemfield.FieldTimeValue:
		m.ResetTimeValue()
		return nil
	}
	return fmt.Errorf("unknown ItemField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item != nil {
		edges = append(edges, itemfield.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itemfield.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem {
		edges = append(edges, itemfield.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case itemfield.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemFieldMutation) ClearEdge(name string) error {
	switch name {
	case itemfield.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown ItemField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemFieldMutation) ResetEdge(name string) error {
	switch name {
	case itemfield.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown ItemField edge %s", name)
}

// LabelMutation represents an operation that mutates the Label nodes in the graph.
type LabelMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	color         *string
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	items         map[uuid.UUID]struct{}
	removeditems  map[uuid.UUID]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Label, error)
	predicates    []predicate.Label
}

var _ ent.Mutation = (*LabelMutation)(nil)

// labelOption allows management of the mutation configuration using functional options.
type labelOption func(*LabelMutation)

// newLabelMutation creates new mutation for the Label entity.
func newLabelMutation(c config, op Op, opts ...labelOption) *LabelMutation {
	m := &LabelMutation{
		config:        c,
		op:            op,
		typ:           TypeLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLabelID sets the ID field of the mutation.
func withLabelID(id uuid.UUID) labelOption {
	return func(m *LabelMutation) {
		var (
			err   error
			once  sync.Once
			value *Label
		)
		m.oldValue = func(ctx context.Context) (*Label, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Label.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLabel sets the old Label of the mutation.
func withLabel(node *Label) labelOption {
	return func(m *LabelMutation) {
		m.oldValue = func(context.Context) (*Label, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Label entities.
func (m *LabelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Label.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LabelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LabelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LabelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LabelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LabelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *LabelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LabelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LabelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LabelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LabelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LabelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[label.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LabelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[label.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LabelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, label.FieldDescription)
}

// SetColor sets the "color" field.
func (m *LabelMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LabelMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *LabelMutation) ClearColor() {
	m.color = nil
	m.clearedFields[label.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *LabelMutation) ColorCleared() bool {
	_, ok := m.clearedFields[label.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *LabelMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, label.FieldColor)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *LabelMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *LabelMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *LabelMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *LabelMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *LabelMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *LabelMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *LabelMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *LabelMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *LabelMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *LabelMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *LabelMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *LabelMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *LabelMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the LabelMutation builder.
func (m *LabelMutation) Where(ps ...predicate.Label) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LabelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LabelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Label, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LabelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LabelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Label).
func (m *LabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, label.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, label.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, label.FieldName)
	}
	if m.description != nil {
		fields = append(fields, label.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, label.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case label.FieldCreatedAt:
		return m.CreatedAt()
	case label.FieldUpdatedAt:
		return m.UpdatedAt()
	case label.FieldName:
		return m.Name()
	case label.FieldDescription:
		return m.Description()
	case label.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case label.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case label.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case label.FieldName:
		return m.OldName(ctx)
	case label.FieldDescription:
		return m.OldDescription(ctx)
	case label.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Label field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case label.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case label.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case label.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case label.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case label.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Label numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(label.FieldDescription) {
		fields = append(fields, label.FieldDescription)
	}
	if m.FieldCleared(label.FieldColor) {
		fields = append(fields, label.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabelMutation) ClearField(name string) error {
	switch name {
	case label.FieldDescription:
		m.ClearDescription()
		return nil
	case label.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Label nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabelMutation) ResetField(name string) error {
	switch name {
	case label.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case label.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case label.FieldName:
		m.ResetName()
		return nil
	case label.FieldDescription:
		m.ResetDescription()
		return nil
	case label.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, label.EdgeGroup)
	}
	if m.items != nil {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case label.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, label.EdgeGroup)
	}
	if m.cleareditems {
		edges = append(edges, label.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabelMutation) EdgeCleared(name string) bool {
	switch name {
	case label.EdgeGroup:
		return m.clearedgroup
	case label.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabelMutation) ClearEdge(name string) error {
	switch name {
	case label.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Label unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabelMutation) ResetEdge(name string) error {
	switch name {
	case label.EdgeGroup:
		m.ResetGroup()
		return nil
	case label.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Label edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	clearedFields   map[string]struct{}
	group           *uuid.UUID
	clearedgroup    bool
	parent          *uuid.UUID
	clearedparent   bool
	children        map[uuid.UUID]struct{}
	removedchildren map[uuid.UUID]struct{}
	clearedchildren bool
	items           map[uuid.UUID]struct{}
	removeditems    map[uuid.UUID]struct{}
	cleareditems    bool
	done            bool
	oldValue        func(context.Context) (*Location, error)
	predicates      []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uuid.UUID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *LocationMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *LocationMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *LocationMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *LocationMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *LocationMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetParentID sets the "parent" edge to the Location entity by id.
func (m *LocationMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Location entity.
func (m *LocationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Location entity was cleared.
func (m *LocationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *LocationMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *LocationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Location entity by ids.
func (m *LocationMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Location entity.
func (m *LocationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Location entity was cleared.
func (m *LocationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Location entity by IDs.
func (m *LocationMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Location entity.
func (m *LocationMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *LocationMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *LocationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *LocationMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *LocationMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *LocationMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *LocationMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *LocationMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *LocationMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *LocationMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldName:
		return m.Name()
	case location.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.group != nil {
		edges = append(edges, location.EdgeGroup)
	}
	if m.parent != nil {
		edges = append(edges, location.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.items != nil {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.removeditems != nil {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgroup {
		edges = append(edges, location.EdgeGroup)
	}
	if m.clearedparent {
		edges = append(edges, location.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, location.EdgeChildren)
	}
	if m.cleareditems {
		edges = append(edges, location.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeGroup:
		return m.clearedgroup
	case location.EdgeParent:
		return m.clearedparent
	case location.EdgeChildren:
		return m.clearedchildren
	case location.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeGroup:
		m.ClearGroup()
		return nil
	case location.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeGroup:
		m.ResetGroup()
		return nil
	case location.EdgeParent:
		m.ResetParent()
		return nil
	case location.EdgeChildren:
		m.ResetChildren()
		return nil
	case location.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// MaintenanceEntryMutation represents an operation that mutates the MaintenanceEntry nodes in the graph.
type MaintenanceEntryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	date           *time.Time
	scheduled_date *time.Time
	name           *string
	description    *string
	cost           *float64
	addcost        *float64
	clearedFields  map[string]struct{}
	item           *uuid.UUID
	cleareditem    bool
	done           bool
	oldValue       func(context.Context) (*MaintenanceEntry, error)
	predicates     []predicate.MaintenanceEntry
}

var _ ent.Mutation = (*MaintenanceEntryMutation)(nil)

// maintenanceentryOption allows management of the mutation configuration using functional options.
type maintenanceentryOption func(*MaintenanceEntryMutation)

// newMaintenanceEntryMutation creates new mutation for the MaintenanceEntry entity.
func newMaintenanceEntryMutation(c config, op Op, opts ...maintenanceentryOption) *MaintenanceEntryMutation {
	m := &MaintenanceEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeMaintenanceEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaintenanceEntryID sets the ID field of the mutation.
func withMaintenanceEntryID(id uuid.UUID) maintenanceentryOption {
	return func(m *MaintenanceEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *MaintenanceEntry
		)
		m.oldValue = func(ctx context.Context) (*MaintenanceEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MaintenanceEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaintenanceEntry sets the old MaintenanceEntry of the mutation.
func withMaintenanceEntry(node *MaintenanceEntry) maintenanceentryOption {
	return func(m *MaintenanceEntryMutation) {
		m.oldValue = func(context.Context) (*MaintenanceEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaintenanceEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaintenanceEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MaintenanceEntry entities.
func (m *MaintenanceEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MaintenanceEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MaintenanceEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MaintenanceEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MaintenanceEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MaintenanceEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MaintenanceEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MaintenanceEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MaintenanceEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MaintenanceEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetItemID sets the "item_id" field.
func (m *MaintenanceEntryMutation) SetItemID(u uuid.UUID) {
	m.item = &u
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *MaintenanceEntryMutation) ItemID() (r uuid.UUID, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldItemID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ResetItemID resets all changes to the "item_id" field.
func (m *MaintenanceEntryMutation) ResetItemID() {
	m.item = nil
}

// SetDate sets the "date" field.
func (m *MaintenanceEntryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *MaintenanceEntryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *MaintenanceEntryMutation) ClearDate() {
	m.date = nil
	m.clearedFields[maintenanceentry.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) DateCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *MaintenanceEntryMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, maintenanceentry.FieldDate)
}

// SetScheduledDate sets the "scheduled_date" field.
func (m *MaintenanceEntryMutation) SetScheduledDate(t time.Time) {
	m.scheduled_date = &t
}

// ScheduledDate returns the value of the "scheduled_date" field in the mutation.
func (m *MaintenanceEntryMutation) ScheduledDate() (r time.Time, exists bool) {
	v := m.scheduled_date
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledDate returns the old "scheduled_date" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldScheduledDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledDate: %w", err)
	}
	return oldValue.ScheduledDate, nil
}

// ClearScheduledDate clears the value of the "scheduled_date" field.
func (m *MaintenanceEntryMutation) ClearScheduledDate() {
	m.scheduled_date = nil
	m.clearedFields[maintenanceentry.FieldScheduledDate] = struct{}{}
}

// ScheduledDateCleared returns if the "scheduled_date" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) ScheduledDateCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldScheduledDate]
	return ok
}

// ResetScheduledDate resets all changes to the "scheduled_date" field.
func (m *MaintenanceEntryMutation) ResetScheduledDate() {
	m.scheduled_date = nil
	delete(m.clearedFields, maintenanceentry.FieldScheduledDate)
}

// SetName sets the "name" field.
func (m *MaintenanceEntryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MaintenanceEntryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MaintenanceEntryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MaintenanceEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MaintenanceEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MaintenanceEntryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[maintenanceentry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MaintenanceEntryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, maintenanceentry.FieldDescription)
}

// SetCost sets the "cost" field.
func (m *MaintenanceEntryMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *MaintenanceEntryMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *MaintenanceEntryMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *MaintenanceEntryMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *MaintenanceEntryMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// ClearItem clears the "item" edge to the Item entity.
func (m *MaintenanceEntryMutation) ClearItem() {
	m.cleareditem = true
	m.clearedFields[maintenanceentry.FieldItemID] = struct{}{}
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *MaintenanceEntryMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *MaintenanceEntryMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *MaintenanceEntryMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the MaintenanceEntryMutation builder.
func (m *MaintenanceEntryMutation) Where(ps ...predicate.MaintenanceEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MaintenanceEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MaintenanceEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MaintenanceEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MaintenanceEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MaintenanceEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MaintenanceEntry).
func (m *MaintenanceEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MaintenanceEntryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, maintenanceentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, maintenanceentry.FieldUpdatedAt)
	}
	if m.item != nil {
		fields = append(fields, maintenanceentry.FieldItemID)
	}
	if m.date != nil {
		fields = append(fields, maintenanceentry.FieldDate)
	}
	if m.scheduled_date != nil {
		fields = append(fields, maintenanceentry.FieldScheduledDate)
	}
	if m.name != nil {
		fields = append(fields, maintenanceentry.FieldName)
	}
	if m.description != nil {
		fields = append(fields, maintenanceentry.FieldDescription)
	}
	if m.cost != nil {
		fields = append(fields, maintenanceentry.FieldCost)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MaintenanceEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		return m.CreatedAt()
	case maintenanceentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case maintenanceentry.FieldItemID:
		return m.ItemID()
	case maintenanceentry.FieldDate:
		return m.Date()
	case maintenanceentry.FieldScheduledDate:
		return m.ScheduledDate()
	case maintenanceentry.FieldName:
		return m.Name()
	case maintenanceentry.FieldDescription:
		return m.Description()
	case maintenanceentry.FieldCost:
		return m.Cost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MaintenanceEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case maintenanceentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case maintenanceentry.FieldItemID:
		return m.OldItemID(ctx)
	case maintenanceentry.FieldDate:
		return m.OldDate(ctx)
	case maintenanceentry.FieldScheduledDate:
		return m.OldScheduledDate(ctx)
	case maintenanceentry.FieldName:
		return m.OldName(ctx)
	case maintenanceentry.FieldDescription:
		return m.OldDescription(ctx)
	case maintenanceentry.FieldCost:
		return m.OldCost(ctx)
	}
	return nil, fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case maintenanceentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case maintenanceentry.FieldItemID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case maintenanceentry.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case maintenanceentry.FieldScheduledDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledDate(v)
		return nil
	case maintenanceentry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case maintenanceentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case maintenanceentry.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MaintenanceEntryMutation) AddedFields() []string {
	var fields []string
	if m.addcost != nil {
		fields = append(fields, maintenanceentry.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MaintenanceEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case maintenanceentry.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case maintenanceentry.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MaintenanceEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(maintenanceentry.FieldDate) {
		fields = append(fields, maintenanceentry.FieldDate)
	}
	if m.FieldCleared(maintenanceentry.FieldScheduledDate) {
		fields = append(fields, maintenanceentry.FieldScheduledDate)
	}
	if m.FieldCleared(maintenanceentry.FieldDescription) {
		fields = append(fields, maintenanceentry.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MaintenanceEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaintenanceEntryMutation) ClearField(name string) error {
	switch name {
	case maintenanceentry.FieldDate:
		m.ClearDate()
		return nil
	case maintenanceentry.FieldScheduledDate:
		m.ClearScheduledDate()
		return nil
	case maintenanceentry.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MaintenanceEntryMutation) ResetField(name string) error {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case maintenanceentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case maintenanceentry.FieldItemID:
		m.ResetItemID()
		return nil
	case maintenanceentry.FieldDate:
		m.ResetDate()
		return nil
	case maintenanceentry.FieldScheduledDate:
		m.ResetScheduledDate()
		return nil
	case maintenanceentry.FieldName:
		m.ResetName()
		return nil
	case maintenanceentry.FieldDescription:
		m.ResetDescription()
		return nil
	case maintenanceentry.FieldCost:
		m.ResetCost()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MaintenanceEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item != nil {
		edges = append(edges, maintenanceentry.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MaintenanceEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maintenanceentry.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MaintenanceEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MaintenanceEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MaintenanceEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem {
		edges = append(edges, maintenanceentry.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MaintenanceEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case maintenanceentry.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MaintenanceEntryMutation) ClearEdge(name string) error {
	switch name {
	case maintenanceentry.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MaintenanceEntryMutation) ResetEdge(name string) error {
	switch name {
	case maintenanceentry.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry edge %s", name)
}

// NotifierMutation represents an operation that mutates the Notifier nodes in the graph.
type NotifierMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	url           *string
	is_active     *bool
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Notifier, error)
	predicates    []predicate.Notifier
}

var _ ent.Mutation = (*NotifierMutation)(nil)

// notifierOption allows management of the mutation configuration using functional options.
type notifierOption func(*NotifierMutation)

// newNotifierMutation creates new mutation for the Notifier entity.
func newNotifierMutation(c config, op Op, opts ...notifierOption) *NotifierMutation {
	m := &NotifierMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifierID sets the ID field of the mutation.
func withNotifierID(id uuid.UUID) notifierOption {
	return func(m *NotifierMutation) {
		var (
			err   error
			once  sync.Once
			value *Notifier
		)
		m.oldValue = func(ctx context.Context) (*Notifier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifier sets the old Notifier of the mutation.
func withNotifier(node *Notifier) notifierOption {
	return func(m *NotifierMutation) {
		m.oldValue = func(context.Context) (*Notifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notifier entities.
func (m *NotifierMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifierMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifierMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notifier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *NotifierMutation) SetGroupID(u uuid.UUID) {
	m.group = &u
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *NotifierMutation) GroupID() (r uuid.UUID, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *NotifierMutation) ResetGroupID() {
	m.group = nil
}

// SetUserID sets the "user_id" field.
func (m *NotifierMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotifierMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotifierMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *NotifierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifierMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *NotifierMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *NotifierMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *NotifierMutation) ResetURL() {
	m.url = nil
}

// SetIsActive sets the "is_active" field.
func (m *NotifierMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *NotifierMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *NotifierMutation) ResetIsActive() {
	m.is_active = nil
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *NotifierMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[notifier.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *NotifierMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *NotifierMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *NotifierMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotifierMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[notifier.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotifierMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotifierMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotifierMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotifierMutation builder.
func (m *NotifierMutation) Where(ps ...predicate.Notifier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notifier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notifier).
func (m *NotifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifierMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, notifier.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notifier.FieldUpdatedAt)
	}
	if m.group != nil {
		fields = append(fields, notifier.FieldGroupID)
	}
	if m.user != nil {
		fields = append(fields, notifier.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, notifier.FieldName)
	}
	if m.url != nil {
		fields = append(fields, notifier.FieldURL)
	}
	if m.is_active != nil {
		fields = append(fields, notifier.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifier.FieldCreatedAt:
		return m.CreatedAt()
	case notifier.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifier.FieldGroupID:
		return m.GroupID()
	case notifier.FieldUserID:
		return m.UserID()
	case notifier.FieldName:
		return m.Name()
	case notifier.FieldURL:
		return m.URL()
	case notifier.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notifier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifier.FieldGroupID:
		return m.OldGroupID(ctx)
	case notifier.FieldUserID:
		return m.OldUserID(ctx)
	case notifier.FieldName:
		return m.OldName(ctx)
	case notifier.FieldURL:
		return m.OldURL(ctx)
	case notifier.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Notifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notifier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifier.FieldGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case notifier.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notifier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifier.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case notifier.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Notifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifierMutation) ResetField(name string) error {
	switch name {
	case notifier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notifier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifier.FieldGroupID:
		m.ResetGroupID()
		return nil
	case notifier.FieldUserID:
		m.ResetUserID()
		return nil
	case notifier.FieldName:
		m.ResetName()
		return nil
	case notifier.FieldURL:
		m.ResetURL()
		return nil
	case notifier.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Notifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, notifier.EdgeGroup)
	}
	if m.user != nil {
		edges = append(edges, notifier.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifier.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case notifier.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifierMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, notifier.EdgeGroup)
	}
	if m.cleareduser {
		edges = append(edges, notifier.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifierMutation) EdgeCleared(name string) bool {
	switch name {
	case notifier.EdgeGroup:
		return m.clearedgroup
	case notifier.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifierMutation) ClearEdge(name string) error {
	switch name {
	case notifier.EdgeGroup:
		m.ClearGroup()
		return nil
	case notifier.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Notifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifierMutation) ResetEdge(name string) error {
	switch name {
	case notifier.EdgeGroup:
		m.ResetGroup()
		return nil
	case notifier.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Notifier edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	email              *string
	password           *string
	is_superuser       *bool
	superuser          *bool
	role               *user.Role
	activated_on       *time.Time
	clearedFields      map[string]struct{}
	group              *uuid.UUID
	clearedgroup       bool
	auth_tokens        map[uuid.UUID]struct{}
	removedauth_tokens map[uuid.UUID]struct{}
	clearedauth_tokens bool
	notifiers          map[uuid.UUID]struct{}
	removednotifiers   map[uuid.UUID]struct{}
	clearednotifiers   bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsSuperuser sets the "is_superuser" field.
func (m *UserMutation) SetIsSuperuser(b bool) {
	m.is_superuser = &b
}

// IsSuperuser returns the value of the "is_superuser" field in the mutation.
func (m *UserMutation) IsSuperuser() (r bool, exists bool) {
	v := m.is_superuser
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperuser returns the old "is_superuser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperuser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperuser: %w", err)
	}
	return oldValue.IsSuperuser, nil
}

// ResetIsSuperuser resets all changes to the "is_superuser" field.
func (m *UserMutation) ResetIsSuperuser() {
	m.is_superuser = nil
}

// SetSuperuser sets the "superuser" field.
func (m *UserMutation) SetSuperuser(b bool) {
	m.superuser = &b
}

// Superuser returns the value of the "superuser" field in the mutation.
func (m *UserMutation) Superuser() (r bool, exists bool) {
	v := m.superuser
	if v == nil {
		return
	}
	return *v, true
}

// OldSuperuser returns the old "superuser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSuperuser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuperuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuperuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuperuser: %w", err)
	}
	return oldValue.Superuser, nil
}

// ResetSuperuser resets all changes to the "superuser" field.
func (m *UserMutation) ResetSuperuser() {
	m.superuser = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetActivatedOn sets the "activated_on" field.
func (m *UserMutation) SetActivatedOn(t time.Time) {
	m.activated_on = &t
}

// ActivatedOn returns the value of the "activated_on" field in the mutation.
func (m *UserMutation) ActivatedOn() (r time.Time, exists bool) {
	v := m.activated_on
	if v == nil {
		return
	}
	return *v, true
}

// OldActivatedOn returns the old "activated_on" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActivatedOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivatedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivatedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivatedOn: %w", err)
	}
	return oldValue.ActivatedOn, nil
}

// ClearActivatedOn clears the value of the "activated_on" field.
func (m *UserMutation) ClearActivatedOn() {
	m.activated_on = nil
	m.clearedFields[user.FieldActivatedOn] = struct{}{}
}

// ActivatedOnCleared returns if the "activated_on" field was cleared in this mutation.
func (m *UserMutation) ActivatedOnCleared() bool {
	_, ok := m.clearedFields[user.FieldActivatedOn]
	return ok
}

// ResetActivatedOn resets all changes to the "activated_on" field.
func (m *UserMutation) ResetActivatedOn() {
	m.activated_on = nil
	delete(m.clearedFields, user.FieldActivatedOn)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *UserMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *UserMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddAuthTokenIDs adds the "auth_tokens" edge to the AuthTokens entity by ids.
func (m *UserMutation) AddAuthTokenIDs(ids ...uuid.UUID) {
	if m.auth_tokens == nil {
		m.auth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.auth_tokens[ids[i]] = struct{}{}
	}
}

// ClearAuthTokens clears the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) ClearAuthTokens() {
	m.clearedauth_tokens = true
}

// AuthTokensCleared reports if the "auth_tokens" edge to the AuthTokens entity was cleared.
func (m *UserMutation) AuthTokensCleared() bool {
	return m.clearedauth_tokens
}

// RemoveAuthTokenIDs removes the "auth_tokens" edge to the AuthTokens entity by IDs.
func (m *UserMutation) RemoveAuthTokenIDs(ids ...uuid.UUID) {
	if m.removedauth_tokens == nil {
		m.removedauth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.auth_tokens, ids[i])
		m.removedauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAuthTokens returns the removed IDs of the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) RemovedAuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedauth_tokens {
		ids = append(ids, id)
	}
	return
}

// AuthTokensIDs returns the "auth_tokens" edge IDs in the mutation.
func (m *UserMutation) AuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.auth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAuthTokens resets all changes to the "auth_tokens" edge.
func (m *UserMutation) ResetAuthTokens() {
	m.auth_tokens = nil
	m.clearedauth_tokens = false
	m.removedauth_tokens = nil
}

// AddNotifierIDs adds the "notifiers" edge to the Notifier entity by ids.
func (m *UserMutation) AddNotifierIDs(ids ...uuid.UUID) {
	if m.notifiers == nil {
		m.notifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifiers[ids[i]] = struct{}{}
	}
}

// ClearNotifiers clears the "notifiers" edge to the Notifier entity.
func (m *UserMutation) ClearNotifiers() {
	m.clearednotifiers = true
}

// NotifiersCleared reports if the "notifiers" edge to the Notifier entity was cleared.
func (m *UserMutation) NotifiersCleared() bool {
	return m.clearednotifiers
}

// RemoveNotifierIDs removes the "notifiers" edge to the Notifier entity by IDs.
func (m *UserMutation) RemoveNotifierIDs(ids ...uuid.UUID) {
	if m.removednotifiers == nil {
		m.removednotifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifiers, ids[i])
		m.removednotifiers[ids[i]] = struct{}{}
	}
}

// RemovedNotifiers returns the removed IDs of the "notifiers" edge to the Notifier entity.
func (m *UserMutation) RemovedNotifiersIDs() (ids []uuid.UUID) {
	for id := range m.removednotifiers {
		ids = append(ids, id)
	}
	return
}

// NotifiersIDs returns the "notifiers" edge IDs in the mutation.
func (m *UserMutation) NotifiersIDs() (ids []uuid.UUID) {
	for id := range m.notifiers {
		ids = append(ids, id)
	}
	return
}

// ResetNotifiers resets all changes to the "notifiers" edge.
func (m *UserMutation) ResetNotifiers() {
	m.notifiers = nil
	m.clearednotifiers = false
	m.removednotifiers = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_superuser != nil {
		fields = append(fields, user.FieldIsSuperuser)
	}
	if m.superuser != nil {
		fields = append(fields, user.FieldSuperuser)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.activated_on != nil {
		fields = append(fields, user.FieldActivatedOn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsSuperuser:
		return m.IsSuperuser()
	case user.FieldSuperuser:
		return m.Superuser()
	case user.FieldRole:
		return m.Role()
	case user.FieldActivatedOn:
		return m.ActivatedOn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsSuperuser:
		return m.OldIsSuperuser(ctx)
	case user.FieldSuperuser:
		return m.OldSuperuser(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActivatedOn:
		return m.OldActivatedOn(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsSuperuser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperuser(v)
		return nil
	case user.FieldSuperuser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuperuser(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActivatedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivatedOn(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldActivatedOn) {
		fields = append(fields, user.FieldActivatedOn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldActivatedOn:
		m.ClearActivatedOn()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsSuperuser:
		m.ResetIsSuperuser()
		return nil
	case user.FieldSuperuser:
		m.ResetSuperuser()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActivatedOn:
		m.ResetActivatedOn()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.group != nil {
		edges = append(edges, user.EdgeGroup)
	}
	if m.auth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.notifiers != nil {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.auth_tokens))
		for id := range m.auth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.notifiers))
		for id := range m.notifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedauth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.removednotifiers != nil {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.removedauth_tokens))
		for id := range m.removedauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.removednotifiers))
		for id := range m.removednotifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroup {
		edges = append(edges, user.EdgeGroup)
	}
	if m.clearedauth_tokens {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.clearednotifiers {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGroup:
		return m.clearedgroup
	case user.EdgeAuthTokens:
		return m.clearedauth_tokens
	case user.EdgeNotifiers:
		return m.clearednotifiers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ResetGroup()
		return nil
	case user.EdgeAuthTokens:
		m.ResetAuthTokens()
		return nil
	case user.EdgeNotifiers:
		m.ResetNotifiers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
